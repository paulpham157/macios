
// This file describes the API that the generator will produce
//
// Authors:
//   Geoff Norton
//   Miguel de Icaza
//   Aaron Bockover
//
// Copyright 2009, Novell, Inc.
// Copyright 2011, 2013, 2015 Xamarin Inc.
//
using ObjCRuntime;
using Foundation;
using CloudKit;
using CoreGraphics;
using CoreFoundation;
#if !MONOMAC
using UIKit;
#endif
#if !TVOS
using Contacts;
#endif
using System;

#if TVOS
using CNPostalAddress = Foundation.NSObject;
#endif

namespace CoreLocation {

	/// <summary>An enumeration whose values specify whether the device is inside or outside a region or unknown.</summary>
	[NoTV]
	[MacCatalyst (13, 1)]
	[Native] // NSInteger -> CLRegion.h
	public enum CLRegionState : long {
		/// <summary>The device's relation to the region could not be determined.</summary>
		Unknown,
		/// <summary>The device is inside the region.</summary>
		Inside,
		/// <summary>The device is outside the region.</summary>
		Outside,
	}

	/// <summary>An enumeration whose values specify the physical proximity of an iBeacon.</summary>
	///     <remarks>
	///       <para>The returned value of <see cref="CoreLocation.CLBeacon.Proximity" /> varies based on power output and the physical environment. It is difficult to translate these qualitative values into absolute physical distances.</para>
	///     </remarks>
	[NoTV]
	[MacCatalyst (13, 1)]
	[Native] // NSInteger -> CLRegion.h
	public enum CLProximity : long {
		/// <summary>The distance to the iBeacon could not be estimated.</summary>
		Unknown,
		/// <summary>The closest distance reported by an iBeacon.</summary>
		Immediate,
		/// <summary>An intermediate distance reported by an iBeacon.</summary>
		Near,
		/// <summary>The furthest distance reported by an iBeacon.</summary>
		Far,
	}

	[ErrorDomain ("CLLocationPushServiceErrorDomain")]
	[iOS (15, 0), NoTV, NoMacCatalyst, NoMac]
	[Native]
	public enum CLLocationPushServiceError : long {
		Unknown = 0,
		MissingPushExtension = 1,
		MissingPushServerEnvironment = 2,
		MissingEntitlement = 3,
		UnsupportedPlatform = 4,
	}

	[Mac (14, 0), iOS (17, 0), MacCatalyst (17, 0), TV (17, 0)]
	[Native]
	public enum CLMonitoringState : ulong {
		Unknown,
		Satisfied,
		Unsatisfied,
		[Mac (14, 2), iOS (17, 2), MacCatalyst (17, 2), NoTV]
		Unmonitored,
	}

	[Mac (14, 0), iOS (17, 0), MacCatalyst (17, 0), TV (17, 0)]
	[Native]
	public enum CLLiveUpdateConfiguration : long {
		Default = 0,
		AutomotiveNavigation,
		OtherNavigation,
		Fitness,
		Airborne,
	}


	/// <summary>Heading data as generated by the CLLocationManager.</summary>
	///     <remarks>
	///       <para>Heading is the direction in which the device is currently moving.</para>
	///       <para>The heading is relative to <see cref="CoreLocation.CLLocationManager.HeadingOrientation" />.</para>
	///     </remarks>
	///     <related type="externalDocumentation" href="https://developer.apple.com/library/ios/documentation/CoreLocation/Reference/CLHeading_Class/index.html">Apple documentation for <c>CLHeading</c></related>
	[NoTV]
	[MacCatalyst (13, 1)]
	[BaseType (typeof (NSObject))]
	[DisableDefaultCtor] // will crash, see CoreLocation.cs for compatibility stubs
	partial interface CLHeading : NSSecureCoding, NSCopying {
		/// <summary>Heading, relative to magnetic North, in degrees.</summary>
		///         <value>To be added.</value>
		///         <remarks>To be added.</remarks>
		[Export ("magneticHeading")]
		double MagneticHeading { get; }

		/// <summary>The heading, relative to true North, in degrees.</summary>
		///         <value>To be added.</value>
		///         <remarks>To be added.</remarks>
		[Export ("trueHeading")]
		double TrueHeading { get; }

		/// <summary>If negative, indicates invalid heading. If positive, the maximum deviation, in degrees, between <see cref="CoreLocation.CLHeading.MagneticHeading" /> and the actual magnetic North.</summary>
		///         <value>If negative, indicates the heading is invalid (due to, for instance heavy magnetic interference or lack of calibration). If positive, it indicates the the maximum deviation, in degrees, between actual magnetic North and <see cref="CoreLocation.CLHeading.MagneticHeading" />.</value>
		///         <remarks>To be added.</remarks>
		[Export ("headingAccuracy")]
		double HeadingAccuracy { get; }

		/// <summary>The geomagnetic signal, in microteslas, along the X axis.</summary>
		///         <value>To be added.</value>
		///         <remarks>To be added.</remarks>
		[Export ("x")]
		double X { get; }

		/// <summary>The geomagnetic signal, in microteslas, along the Y axis.</summary>
		///         <value>To be added.</value>
		///         <remarks>To be added.</remarks>
		[Export ("y")]
		double Y { get; }

		/// <summary>The geomagnetic signal, in microteslas, along the Z axis.</summary>
		///         <value>To be added.</value>
		///         <remarks>To be added.</remarks>
		[Export ("z")]
		double Z { get; }

		/// <summary>The time at which the reading was taken.</summary>
		///         <value>To be added.</value>
		///         <remarks>To be added.</remarks>
		[Export ("timestamp", ArgumentSemantic.Copy)]
		NSDate Timestamp { get; }
	}

	/// <summary>Location information as generated byt he CLLocationManager class.</summary>
	/// <remarks>To be added.</remarks>
	/// <related type="sample" href="https://github.com/xamarin/ios-samples/tree/master/CoreLocation/">Example_CoreLocation</related>
	/// <related type="externalDocumentation" href="https://developer.apple.com/library/ios/documentation/CoreLocation/Reference/CLLocation_Class/index.html">Apple documentation for <c>CLLocation</c></related>
	[BaseType (typeof (NSObject))]
	partial interface CLLocation : NSSecureCoding, NSCopying, CKRecordValue {
		/// <summary>The location's position on the globe.</summary>
		///         <value>To be added.</value>
		///         <remarks>To be added.</remarks>
		[Export ("coordinate")]
		CLLocationCoordinate2D Coordinate { get; }

		/// <summary>The altitude, in meters above sea level.</summary>
		///         <value>To be added.</value>
		///         <remarks>To be added.</remarks>
		[Export ("altitude")]
		double Altitude { get; }

		/// <summary>The radius, in meters, of the uncertainty of the location.</summary>
		///         <value>The radius, in meters.</value>
		///         <remarks>To be added.</remarks>
		[Export ("horizontalAccuracy")]
		double HorizontalAccuracy { get; }

		/// <summary>The radius, in meters, of the uncertainty of the location.</summary>
		///         <value>To be added.</value>
		///         <remarks>To be added.</remarks>
		[Export ("verticalAccuracy")]
		double VerticalAccuracy { get; }

		/// <summary>The direction, in positive degrees, in which the device is moving relative to true North.</summary>
		///         <value>Negative values are invalid. Travel due West is 270, not -90.</value>
		///         <remarks>
		///           <para>This property is not be available on all devices.</para>
		///         </remarks>
		[TV (13, 0)] // API_UNAVAILABLE(tvos) removed in Xcode 11 beta 1
		[MacCatalyst (13, 1)]
		[Export ("course")]
		double Course { get; }

		[TV (13, 4), iOS (13, 4)]
		[MacCatalyst (13, 1)]
		[Export ("courseAccuracy")]
		double CourseAccuracy { get; }

		/// <summary>The instantaneous speed of the device, in meters per second.</summary>
		///         <value>Negative values are invalid.</value>
		///         <remarks>To be added.</remarks>
		[TV (13, 0)] // API_UNAVAILABLE(tvos) removed in Xcode 11 beta 1
		[MacCatalyst (13, 1)]
		[Export ("speed")]
		double Speed { get; }

		[TV (13, 4), iOS (13, 4)]
		[MacCatalyst (13, 1)]
		[Export ("speedAccuracy")]
		double SpeedAccuracy { get; }

		/// <summary>The time at which the <see cref="CoreLocation.CLLocation" /> measurement was taken.</summary>
		///         <value>To be added.</value>
		///         <remarks>To be added.</remarks>
		[Export ("timestamp", ArgumentSemantic.Copy)]
		NSDate Timestamp { get; }

		/// <param name="latitude">The latitude, in decimal degrees, with the Northern hemisphere positive.</param>
		/// <param name="longitude">The longitude, in decimal degrees, with the Eastern hemisphere positive.</param>
		/// <summary>Constructor that produces a location specified by <paramref name="latitude" /> and <paramref name="longitude" />.</summary>
		/// <remarks>To be added.</remarks>
		[Export ("initWithLatitude:longitude:")]
		NativeHandle Constructor (double latitude, double longitude);

		/// <param name="coordinate">To be added.</param>
		/// <param name="altitude">To be added.</param>
		/// <param name="hAccuracy">To be added.</param>
		/// <param name="vAccuracy">To be added.</param>
		/// <param name="timestamp">To be added.</param>
		/// <summary>Constructor that allows the app developer to specify the accuracy and time.</summary>
		/// <remarks>To be added.</remarks>
		[Export ("initWithCoordinate:altitude:horizontalAccuracy:verticalAccuracy:timestamp:")]
		NativeHandle Constructor (CLLocationCoordinate2D coordinate, double altitude, double hAccuracy, double vAccuracy, NSDate timestamp);

		/// <param name="location">To be added.</param>
		///         <summary>Calculates the distance, in meters, between the <see cref="CoreLocation.CLLocation" /> and <paramref name="location" />.</summary>
		///         <returns>The great-arc distance, in meters, along the surface of the Earth. Altitudes are not taken into consideration.</returns>
		///         <remarks>To be added.</remarks>
		[Export ("distanceFromLocation:")]
		double DistanceFrom (CLLocation location);

		/// <param name="coordinate">To be added.</param>
		/// <param name="altitude">To be added.</param>
		/// <param name="hAccuracy">To be added.</param>
		/// <param name="vAccuracy">To be added.</param>
		/// <param name="course">To be added.</param>
		/// <param name="speed">To be added.</param>
		/// <param name="timestamp">To be added.</param>
		/// <summary>Constructor that allows the app developer to specify speed.</summary>
		/// <remarks>To be added.</remarks>
		[Export ("initWithCoordinate:altitude:horizontalAccuracy:verticalAccuracy:course:speed:timestamp:")]
		NativeHandle Constructor (CLLocationCoordinate2D coordinate, double altitude, double hAccuracy, double vAccuracy, double course, double speed, NSDate timestamp);

		[TV (13, 4), iOS (13, 4)]
		[MacCatalyst (13, 1)]
		[Export ("initWithCoordinate:altitude:horizontalAccuracy:verticalAccuracy:course:courseAccuracy:speed:speedAccuracy:timestamp:")]
		NativeHandle Constructor (CLLocationCoordinate2D coordinate, double altitude, double hAccuracy, double vAccuracy, double course, double courseAccuracy, double speed, double speedAccuracy, NSDate timestamp);

		[TV (15, 0), iOS (15, 0), MacCatalyst (15, 0)]
		[Export ("initWithCoordinate:altitude:horizontalAccuracy:verticalAccuracy:course:courseAccuracy:speed:speedAccuracy:timestamp:sourceInfo:")]
		NativeHandle Constructor (CLLocationCoordinate2D coordinate, double altitude, double horizontalAccuracy, double verticalAccuracy, double course, double courseAccuracy, double speed, double speedAccuracy, NSDate timestamp, CLLocationSourceInformation sourceInfo);

		// Apple keep changing the 'introduction' of this field (5.0->8.0->5.0) but it was not available in 6.1
		// nor in 7.0 - but it works on my iPad3 running iOS 7.1
		/// <summary>Represents the value associated with the constant kCLErrorUserInfoAlternateRegionKey</summary>
		///         <value>
		///         </value>
		///         <remarks>To be added.</remarks>
		[NoTV]
		[MacCatalyst (13, 1)]
		[Field ("kCLErrorUserInfoAlternateRegionKey")]
		NSString ErrorUserInfoAlternateRegionKey { get; }

#if !XAMCORE_5_0
		/// <summary>To be added.</summary>
		///         <value>To be added.</value>
		///         <remarks>To be added.</remarks>
		[Obsolete ("Use 'AccuracyBestForNavigation' instead.")]
		[Field ("kCLLocationAccuracyBestForNavigation")]
		double AccurracyBestForNavigation { get; }
#endif

		[Field ("kCLLocationAccuracyBestForNavigation")]
		double AccuracyBestForNavigation { get; }

		/// <summary>To be added.</summary>
		///         <value>To be added.</value>
		///         <remarks>To be added.</remarks>
		[Field ("kCLLocationAccuracyBest")]
		double AccuracyBest { get; }

		/// <summary>To be added.</summary>
		///         <value>To be added.</value>
		///         <remarks>To be added.</remarks>
		[Field ("kCLLocationAccuracyNearestTenMeters")]
		double AccuracyNearestTenMeters { get; }

		/// <summary>To be added.</summary>
		///         <value>To be added.</value>
		///         <remarks>To be added.</remarks>
		[Field ("kCLLocationAccuracyHundredMeters")]
		double AccuracyHundredMeters { get; }

		/// <summary>To be added.</summary>
		///         <value>To be added.</value>
		///         <remarks>To be added.</remarks>
		[Field ("kCLLocationAccuracyKilometer")]
		double AccuracyKilometer { get; }

		/// <summary>To be added.</summary>
		///         <value>To be added.</value>
		///         <remarks>To be added.</remarks>
		[Field ("kCLLocationAccuracyThreeKilometers")]
		double AccuracyThreeKilometers { get; }

		[TV (14, 0), iOS (14, 0)]
		[MacCatalyst (14, 0)]
		[Field ("kCLLocationAccuracyReduced")]
		double AccuracyReduced { get; }

		/// <summary>To be added.</summary>
		///         <value>To be added.</value>
		///         <remarks>To be added.</remarks>
		[MacCatalyst (13, 1)]
		[NullAllowed, Export ("floor", ArgumentSemantic.Copy)]
		CLFloor Floor { get; }

		[TV (15, 0), iOS (15, 0), MacCatalyst (15, 0)]
		[Export ("ellipsoidalAltitude")]
		double EllipsoidalAltitude { get; }

		[TV (15, 0), iOS (15, 0), MacCatalyst (15, 0)]
		[NullAllowed, Export ("sourceInformation")]
		CLLocationSourceInformation SourceInformation { get; }
	}

	/// <summary>Information describing a building level.</summary>
	/// <remarks>To be added.</remarks>
	/// <related type="externalDocumentation" href="https://developer.apple.com/library/ios/documentation/CoreLocation/Reference/CLFloor_class/index.html">Apple documentation for <c>CLFloor</c></related>
	[MacCatalyst (13, 1)]
	[BaseType (typeof (NSObject))]
	partial interface CLFloor : NSSecureCoding, NSCopying {
		/// <summary>To be added.</summary>
		///         <value>To be added.</value>
		///         <remarks>To be added.</remarks>
		[Export ("level")]
		nint Level { get; }
	}

	delegate void RequestHistoricalLocationsCompletionHandler (CLLocation [] locations, [NullAllowed] NSError error);

	[BaseType (typeof (NSObject), Delegates = new string [] { "WeakDelegate" }, Events = new Type [] { typeof (CLLocationManagerDelegate) })]
	partial interface CLLocationManager {
		/// <summary>An instance of the CoreLocation.ICLLocationManagerDelegate model class which acts as the class delegate.</summary>
		///         <value>The instance of the CoreLocation.ICLLocationManagerDelegate model class</value>
		///         <remarks>
		///           <para>The delegate instance assigned to this object will be used to handle events or provide data on demand to this class.</para>
		///           <para>When setting the Delegate or WeakDelegate values events will be delivered to the specified instance instead of being delivered to the C#-style events</para>
		///           <para>This is the strongly typed version of the object, developers should use the WeakDelegate property instead if they want to merely assign a class derived from NSObject that has been decorated with [Export] attributes.</para>
		///         </remarks>
		[Wrap ("WeakDelegate")]
		ICLLocationManagerDelegate Delegate { get; set; }

		/// <summary>An object that can respond to the delegate protocol for this type</summary>
		///         <value>The instance that will respond to events and data requests.</value>
		///         <remarks>
		///           <para>The delegate instance assigned to this object will be used to handle events or provide data on demand to this class.</para>
		///           <para>When setting the Delegate or WeakDelegate values events will be delivered to the specified instance instead of being delivered to the C#-style events</para>
		///           <para>   Methods must be decorated with the [Export ("selectorName")] attribute to respond to each method from the protocol.   Alternatively use the Delegate method which is strongly typed and does not require the [Export] attributes on methods.</para>
		///         </remarks>
		[Export ("delegate", ArgumentSemantic.Assign)]
		[NullAllowed]
		NSObject WeakDelegate { get; set; }

		/// <summary>The minimum horizontal distance, in meters, the device has to move before issuing a location update.</summary>
		///         <value>The default value is <see cref="CoreLocation.CLLocationDistance.None" />.</value>
		///         <remarks>
		///           <para>If this value is set to <see cref="CoreLocation.CLLocationDistance.None" />, the app will receive all location updates.</para>
		///         </remarks>
		[Export ("distanceFilter", ArgumentSemantic.Assign)]
		double DistanceFilter { get; set; }

		/// <summary>The accuracy preferred by the app. (Coarser accuracies consume less power.)</summary>
		///         <value>The default value is <see cref="CoreLocation.CLLocation.AccuracyBest" />.</value>
		///         <remarks>
		///           <para>Application developers should set this value to the coarsest resolution suitable to their needs.</para>
		///         </remarks>
		[Export ("desiredAccuracy", ArgumentSemantic.Assign)]
		double DesiredAccuracy { get; set; }

		/// <summary>The most recently-retrieved <see cref="CoreLocation.CLLocation" />.</summary>
		///         <value>To be added.</value>
		///         <remarks>To be added.</remarks>
		[NullAllowed, Export ("location", ArgumentSemantic.Copy)]
		CLLocation Location { get; }

		/// <summary>Starts updating the location</summary>
		///         <remarks>To be added.</remarks>
		[NoTV]
		[MacCatalyst (13, 1)]
		[Export ("startUpdatingLocation")]
		void StartUpdatingLocation ();

		/// <summary>Stops updating the location.</summary>
		///         <remarks>To be added.</remarks>
		[Export ("stopUpdatingLocation")]
		void StopUpdatingLocation ();

		/// <summary>Whether location services are available.</summary>
		///         <value>
		///           <see langword="true" /> if the necessary hardware exists and the user has allowed the app's request for access.</value>
		///         <remarks>To be added.</remarks>
		[Export ("locationServicesEnabled"), Static]
		bool LocationServicesEnabled { get; }

		/// <summary>The minimum change in heading, in degreees, necessary to generate a location update.</summary>
		///         <value>The default value is 1 (degree).</value>
		///         <remarks>To be added.</remarks>
		[NoTV]
		[MacCatalyst (13, 1)]
		[Export ("headingFilter", ArgumentSemantic.Assign)]
		double HeadingFilter { get; set; }

		/// <summary>Starts updating the heading.</summary>
		///         <remarks>
		///           <para>Heading information is only available on devices with a hardware magnetometer. (See <see cref="CoreLocation.CLLocationManager.HeadingAvailable" />.)</para>
		///         </remarks>
		[NoTV]
		[MacCatalyst (13, 1)]
		[Export ("startUpdatingHeading")]
		void StartUpdatingHeading ();

		/// <summary>Stops updating the heading.</summary>
		///         <remarks>To be added.</remarks>
		[NoTV]
		[MacCatalyst (13, 1)]
		[Export ("stopUpdatingHeading")]
		void StopUpdatingHeading ();

		/// <summary>Removes the heading calibration view from the display.</summary>
		///         <remarks>To be added.</remarks>
		[NoTV]
		[MacCatalyst (13, 1)]
		[Export ("dismissHeadingCalibrationDisplay")]
		void DismissHeadingCalibrationDisplay ();

		/// <summary>Developers should not use this deprecated property. </summary>
		///         <value>To be added.</value>
		///         <remarks>
		///           <para>Application developers should not use this deprecated property.</para>
		///           <para>Prior to iOS 6, this property was displayed to the user when they were prompted as to whether to allow location services.</para>
		///         </remarks>
		[NoTV]
		[Deprecated (PlatformName.iOS, 6, 0)]
		[Deprecated (PlatformName.MacOSX, 11, 0, message: "Set the purpose using the NSLocationUsageDescription key in the Info.plist instead.")]
		[MacCatalyst (13, 1)]
		[Deprecated (PlatformName.MacCatalyst, 13, 1)]
		// Default property value is null but it cannot be set to that value
		// it crash when a null is provided
		[NullAllowed, Export ("purpose")]
		string Purpose { get; set; }

		/// <summary>Whether the <see cref="CoreLocation.CLLocationManager.Heading" /> property is not <see langword="null" />.</summary>
		///         <value>To be added.</value>
		///         <remarks>To be added.</remarks>
		[NoTV]
		[MacCatalyst (13, 1)]
		[Export ("headingAvailable"), Static]
		bool HeadingAvailable { get; }

		/// <summary>Whether "significant location change" monitoring (e.g., via cell tower switch) is available.</summary>
		///         <value>
		///           <see langword="true" /> if such monitoring is available.</value>
		///         <remarks>
		///           <para>"Significant location change" monitoring is the lowest-power location monitoring mode and is done primarily via tracking cellphone tower changes. This type of monitoring is primarily useful for applications that are satisfied by approximate location data. </para>
		///         </remarks>
		[NoTV]
		[MacCatalyst (13, 1)]
		[Export ("significantLocationChangeMonitoringAvailable"), Static]
		bool SignificantLocationChangeMonitoringAvailable { get; }

		/// <summary>Application developers should use <see cref="CoreLocation.CLLocationManager.IsMonitoringAvailable(System.Type)" /> rather than this deprecated method.</summary>
		///         <value>To be added.</value>
		///         <remarks>To be added.</remarks>
		[NoTV]
		[Deprecated (PlatformName.iOS, 7, 0, message: "Use 'IsMonitoringAvailable' instead.")]
		[Deprecated (PlatformName.MacOSX, 10, 10, message: "Use 'IsMonitoringAvailable' instead.")]
		[MacCatalyst (13, 1)]
		[Deprecated (PlatformName.MacCatalyst, 13, 1, message: "Use 'IsMonitoringAvailable' instead.")]
		[Export ("regionMonitoringAvailable"), Static]
		bool RegionMonitoringAvailable { get; }

		/// <summary>Application developers should use <see cref="CoreLocation.CLLocationManager.IsMonitoringAvailable(System.Type)" /> rather than this deprecated method.</summary>
		///         <value>To be added.</value>
		///         <remarks>To be added.</remarks>
		[NoTV]
		[Deprecated (PlatformName.iOS, 6, 0, message: "Use 'IsMonitoringAvailable' and 'AuthorizationStatus' instead.")]
		[Deprecated (PlatformName.MacOSX, 10, 10, message: "Use 'IsMonitoringAvailable' and 'AuthorizationStatus' instead.")]
		[MacCatalyst (13, 1)]
		[Deprecated (PlatformName.MacCatalyst, 13, 1, message: "Use 'IsMonitoringAvailable' and 'AuthorizationStatus' instead.")]
		[Export ("regionMonitoringEnabled"), Static]
		bool RegionMonitoringEnabled { get; }

		/// <summary>The orientation used to determine heading calculations.</summary>
		///         <value>The default value assumes that the app, in upright portrait mode, represents due North.</value>
		///         <remarks>To be added.</remarks>
		[NoTV]
		[MacCatalyst (13, 1)]
		[Export ("headingOrientation", ArgumentSemantic.Assign)]
		CLDeviceOrientation HeadingOrientation { get; set; }

		/// <summary>The most recent heading (direction in which the device is traveling).</summary>
		///         <value>This value may be <see langword="null" /> if heading updates have not been started.</value>
		///         <remarks>
		///           <para>Heading information is only available on devices with a hardware magnetometer. (See <see cref="CoreLocation.CLLocationManager.HeadingAvailable" />.)</para>
		///         </remarks>
		[NoTV]
		[MacCatalyst (13, 1)]
		[NullAllowed, Export ("heading", ArgumentSemantic.Copy)]
		CLHeading Heading { get; }

		/// <summary>The largest boundary distance, in meters, that can be assigned to a region.</summary>
		///         <value>A return value of -1 indicates that region monitoring is unavailable.</value>
		///         <remarks>To be added.</remarks>
		[NoTV]
		[MacCatalyst (13, 1)]
		[Export ("maximumRegionMonitoringDistance")]
		double MaximumRegionMonitoringDistance { get; }

		/// <summary>The set of <see cref="CoreLocation.CLRegion" />s being monitored by the app.</summary>
		///         <value>To be added.</value>
		///         <remarks>
		///           <para>The <see cref="CoreLocation.CLRegion" />s objects returned by this method may be different than those created by the app. Application developers should use the <see cref="CoreLocation.CLRegion.Identifier" /> property to determine equality.</para>
		///         </remarks>
		[NoTV]
		[MacCatalyst (13, 1)]
		[Export ("monitoredRegions", ArgumentSemantic.Copy)]
		NSSet MonitoredRegions { get; }

		/// <summary>Starts monitoring for significant changes.</summary>
		///         <remarks>
		///           <para>This is the most energy-efficient monitoring mode and primarily relies on cellphone-tower changes. It is most appropriate for applications that do not have precise location-monitoring needs. </para>
		///         </remarks>
		[NoTV]
		[MacCatalyst (13, 1)]
		[Export ("startMonitoringSignificantLocationChanges")]
		void StartMonitoringSignificantLocationChanges ();

		/// <summary>Starts monitoring significant location changes.</summary>
		///         <remarks>To be added.</remarks>
		[NoTV]
		[MacCatalyst (13, 1)]
		[Export ("stopMonitoringSignificantLocationChanges")]
		void StopMonitoringSignificantLocationChanges ();

		/// <param name="region">Region to monitor</param>
		///         <param name="desiredAccuracy">Accuracy in meters.</param>
		///         <summary>Starts monitoring the region.</summary>
		///         <remarks>
		///           <para>An application may monitor up to 20 uniquely-named (defined by <see cref="CoreLocation.CLRegion.Identifier" />) regions. The speed with which region notifications are delivered is dependent on network connectivity.</para>
		///           <para>Region entry/exit notifications typically arrive within 3-5 minutes. Regions of less than 400m radius work better on iPhone 4S and later devices. (Notification speed seems fastest on devices with M7 coprocessors.)</para>
		///         </remarks>
		[NoTV]
		[NoMac]
		[Deprecated (PlatformName.iOS, 6, 0)]
		[MacCatalyst (13, 1)]
		[Deprecated (PlatformName.MacCatalyst, 13, 1)]
		[Export ("startMonitoringForRegion:desiredAccuracy:")]
		void StartMonitoring (CLRegion region, double desiredAccuracy);

		/// <param name="region">To be added.</param>
		///         <summary>Stops monitoring the <paramref name="region" />.</summary>
		///         <remarks>To be added.</remarks>
		[NoTV]
		[MacCatalyst (13, 1)]
		[Deprecated (PlatformName.iOS, 17, 0, message: "Use 'void RemoveCondition (string identifier)' instead.")]
		[Deprecated (PlatformName.MacCatalyst, 17, 0, message: "Use 'void RemoveCondition (string identifier)' instead.")]
		[Deprecated (PlatformName.MacOSX, 14, 0, message: "Use 'void RemoveCondition (string identifier)' instead.")]
		[Export ("stopMonitoringForRegion:")]
		void StopMonitoring (CLRegion region);

		[TV (14, 0), iOS (14, 0)]
		[MacCatalyst (14, 0)]
		[Export ("authorizationStatus")]
		CLAuthorizationStatus AuthorizationStatus { get; }

		/// <summary>The authorization status of the app (e.g., if the app is denied access to location services).</summary>
		///         <value>The value is determined by the user's interaction with the standard permissions dialog.</value>
		///         <remarks>
		///           <para>See the "Requesting Authorization" discussion in the class-level remarks: <see cref="CoreLocation.CLLocationManager" />.</para>
		///         </remarks>
		///         <altmember cref="CoreLocation.AuthorizationChanged" />
		[Deprecated (PlatformName.iOS, 14, 0, message: "Use the instance property 'AuthorizationStatus' instead.")]
		[Deprecated (PlatformName.MacOSX, 11, 0, message: "Use the instance 'AuthorizationStatus' property instead.")]
		[Deprecated (PlatformName.TvOS, 14, 0, message: "Use the instance property AuthorizationStatus' instead.")]
		[Deprecated (PlatformName.MacCatalyst, 14, 0, message: "Use the instance property 'AuthorizationStatus' instead.")]
		[Export ("authorizationStatus")]
		[Static]
		CLAuthorizationStatus Status { get; }

		/// <param name="region">The region to be monitored.</param>
		///         <summary>Begins monitoring <paramref name="region" /> for entry and exit.</summary>
		///         <remarks>
		///           <para>An application may monitor up to 20 uniquely-named (defined by <see cref="CoreLocation.CLRegion.Identifier" />) regions. The speed with which region notifications are delivered is dependent on network connectivity.</para>
		///           <para>Region entry/exit notifications typically arrive within 3-5 minutes. Regions of less than 400m radius work better on iPhone 4S and later devices. (Notification speed seems fastest on devices with M7 coprocessors.)</para>
		///         </remarks>
		[NoTV]
		[MacCatalyst (13, 1)]
		[Deprecated (PlatformName.iOS, 17, 0, message: "Use 'void AddCondition (CLCondition condition, string identifier)' instead.")]
		[Deprecated (PlatformName.MacCatalyst, 17, 0, message: "Use 'void AddCondition (CLCondition condition, string identifier)' instead.")]
		[Deprecated (PlatformName.MacOSX, 14, 0, message: "Use 'void AddCondition (CLCondition condition, string identifier)' instead.")]
		[Export ("startMonitoringForRegion:")]
		void StartMonitoring (CLRegion region);

		/// <summary>Used to provide the operating system clues for better power consumption / accuracy.</summary>
		///         <value>The default value is <see cref="CoreLocation.CLActivityType.Other" />.</value>
		///         <remarks>
		///           <para>Application developers should set this property when possible. It provides clues to the system about the application's need. For instance, if set to <see cref="CoreLocation.CLActivityType.AutomotiveNavigation" /> and the device has not moved for awhile, the system might power down updates until movement is detected.</para>
		///         </remarks>
		[NoTV]
		[MacCatalyst (13, 1)]
		[Export ("activityType", ArgumentSemantic.Assign)]
		CLActivityType ActivityType { get; set; }

		/// <summary>Whether the system is allowed to pause location updates (for instance, if the device has not moved in awhile).</summary>
		///         <value>The default value is <see langword="true" />.</value>
		///         <remarks>
		///           <para>Application developers can make pauses more logical by assigning <see cref="CoreLocation.CLLocationManager.ActivityType" /> appropriately.</para>
		///         </remarks>
		[NoTV]
		[MacCatalyst (13, 1)]
		[Export ("pausesLocationUpdatesAutomatically", ArgumentSemantic.Assign)]
		bool PausesLocationUpdatesAutomatically { get; set; }

		/// <include file="../docs/api/CoreLocation/CLLocationManager.xml" path="/Documentation/Docs[@DocId='M:CoreLocation.CLLocationManager.AllowDeferredLocationUpdatesUntil(System.Double,System.Double)']/*" />
		[NoTV]
		[NoMac]
		[Deprecated (PlatformName.iOS, 13, 0, message: "Not used anymore. Call will not have any effect.")]
		[NoMacCatalyst]
		[Deprecated (PlatformName.MacCatalyst, 13, 1, message: "Not used anymore. Call will not have any effect.")]
		[Export ("allowDeferredLocationUpdatesUntilTraveled:timeout:")]
		void AllowDeferredLocationUpdatesUntil (double distance, double timeout);

		/// <summary>Turns off deferred background location updates.</summary>
		///         <remarks>To be added.</remarks>
		///         <altmember cref="CoreLocation.CLLocationManager.AllowDeferredLocationUpdatesUntil" />
		[NoTV]
		[NoMac]
		[Deprecated (PlatformName.iOS, 13, 0, message: "Not used anymore. Call will not have any effect.")]
		[NoMacCatalyst]
		[Deprecated (PlatformName.MacCatalyst, 13, 1, message: "Not used anymore. Call will not have any effect.")]
		[Export ("disallowDeferredLocationUpdates")]
		void DisallowDeferredLocationUpdates ();

		/// <summary>Whether background-generated deferred location data are available.</summary>
		///         <value>To be added.</value>
		///         <remarks>To be added.</remarks>
		[NoTV]
		[Deprecated (PlatformName.iOS, 13, 0, message: "Not used anymore. It will always return 'false'.")]
		[Deprecated (PlatformName.MacOSX, 10, 15, message: "Not used anymore. It will always return 'false'.")]
		[MacCatalyst (13, 1)]
		[Deprecated (PlatformName.MacCatalyst, 13, 1, message: "Not used anymore. It will always return 'false'.")]
		[Static]
		[Export ("deferredLocationUpdatesAvailable")]
		bool DeferredLocationUpdatesAvailable { get; }

		/// <summary>Represents the value associated with the constant CLTimeInternalMax</summary>
		///         <value>
		///         </value>
		///         <remarks>To be added.</remarks>
		[MacCatalyst (13, 1)]
		[Field ("CLTimeIntervalMax")]
		double MaxTimeInterval { get; }

		/// <include file="../docs/api/CoreLocation/CLLocationManager.xml" path="/Documentation/Docs[@DocId='M:CoreLocation.CLLocationManager.IsMonitoringAvailable(ObjCRuntime.Class)']/*" />
		[NoTV]
		[MacCatalyst (13, 1)]
		[Static, Export ("isMonitoringAvailableForClass:")]
		bool IsMonitoringAvailable (Class regionClass);

		/// <summary>The set of <see cref="CoreLocation.CLRegion" />s being tracked using ranging.</summary>
		///         <value>To be added.</value>
		///         <remarks>To be added.</remarks>
		[NoTV]
		[NoMac]
		[Deprecated (PlatformName.iOS, 13, 0, message: "Use 'RangedBeaconConstraints' instead.")]
		[MacCatalyst (13, 1)]
		[Deprecated (PlatformName.MacCatalyst, 13, 1, message: "Use 'RangedBeaconConstraints' instead.")]
		[Export ("rangedRegions", ArgumentSemantic.Copy)]
		NSSet RangedRegions { get; }

		[NoTV, iOS (13, 0)]
		[MacCatalyst (13, 1)]
		[Export ("rangedBeaconConstraints", ArgumentSemantic.Copy)]
		NSSet<CLBeaconIdentityConstraint> RangedBeaconConstraints { get; }

		/// <param name="region">The region whose state is being queried.</param>
		///         <summary>Asynchronously requests information on the state of the <paramref name="region" />.</summary>
		///         <remarks>
		///           <para>Application developers must have assigned the <see cref="CoreLocation.CLLocationManager.Delegate" /> property to an object that implements <see cref="CoreLocation.CLLocationManagerDelegate.DidDetermineState(CoreLocation.CLLocationManager,CoreLocation.CLRegionState,CoreLocation.CLRegion)" /> prior to calling this method. The <see cref="CoreLocation.CLLocationManagerDelegate.DidDetermineState(CoreLocation.CLLocationManager,CoreLocation.CLRegionState,CoreLocation.CLRegion)" /> method will be called at some point subsequently.</para>
		///         </remarks>
		[NoTV]
		[MacCatalyst (13, 1)]
		[Deprecated (PlatformName.iOS, 17, 0, message: "Use the class 'CLMonitor' instead.")]
		[Deprecated (PlatformName.MacCatalyst, 17, 0, message: "Use the class 'CLMonitor' instead.")]
		[Deprecated (PlatformName.MacOSX, 14, 0, message: "Use the class 'CLMonitor' instead.")]
		[Export ("requestStateForRegion:")]
		void RequestState (CLRegion region);

		/// <param name="region">The region being checked.</param>
		///         <summary>Starts delivering notifications about beacons in <paramref name="region" />.</summary>
		///         <remarks>
		///           <para>Prior to calling this method, application developers must assign to <see cref="CoreLocation.CLLocationManager.Delegate" /> an object that implements the <see cref="CoreLocation.CLLocationManagerDelegate.DidRangeBeacons(CoreLocation.CLLocationManager,CoreLocation.CLBeacon[],CoreLocation.CLBeaconRegion)" /> and <see cref="CoreLocation.CLLocationManagerDelegate.RangingBeaconsDidFailForRegion(CoreLocation.CLLocationManager,CoreLocation.CLBeaconRegion,Foundation.NSError)" /> methods.</para>
		///         </remarks>
		[NoTV]
		[NoMac]
		[NoMacCatalyst]
		[Deprecated (PlatformName.iOS, 13, 0, message: "Use 'StartRangingBeacons(CLBeaconIdentityConstraint)' instead.")]
		[Deprecated (PlatformName.MacCatalyst, 13, 1, message: "Use 'StartRangingBeacons(CLBeaconIdentityConstraint)' instead.")]
		[Export ("startRangingBeaconsInRegion:")]
		void StartRangingBeacons (CLBeaconRegion region);

		[NoTV, iOS (13, 0)]
		[MacCatalyst (13, 1)]
		[Export ("startRangingBeaconsSatisfyingConstraint:")]
		void StartRangingBeacons (CLBeaconIdentityConstraint constraint);

		/// <param name="region">To be added.</param>
		///         <summary>Stops tracking beacons in the <paramref name="region" />.</summary>
		///         <remarks>To be added.</remarks>
		[NoTV]
		[NoMac]
		[NoMacCatalyst]
		[Deprecated (PlatformName.iOS, 13, 0, message: "Use 'StopRangingBeacons(CLBeaconIdentityConstraint)' instead.")]
		[Deprecated (PlatformName.MacCatalyst, 13, 1, message: "Use 'StopRangingBeacons(CLBeaconIdentityConstraint)' instead.")]
		[Export ("stopRangingBeaconsInRegion:")]
		void StopRangingBeacons (CLBeaconRegion region);

		[NoTV, iOS (13, 0)]
		[MacCatalyst (13, 1)]
		[Export ("stopRangingBeaconsSatisfyingConstraint:")]
		void StopRangingBeacons (CLBeaconIdentityConstraint constraint);

		/// <summary>Gets a Boolean value that tells whether the device can range Bluetooth beacons.</summary>
		///         <value>To be added.</value>
		///         <remarks>To be added.</remarks>
		[NoTV]
		[MacCatalyst (13, 1)]
		[Static]
		[Export ("isRangingAvailable")]
		bool IsRangingAvailable { get; }

		/// <summary>Displays an interface to the user that requests authorization to use location services any time that the app is in the foreground.</summary>
		///         <remarks>To be added.</remarks>
		[MacCatalyst (13, 1)]
		[Export ("requestWhenInUseAuthorization")]
		void RequestWhenInUseAuthorization ();

		/// <summary>Displays an interface to the user that requests authorization to use location services any time that the app is running.</summary>
		///         <remarks>To be added.</remarks>
		[NoTV]
		[MacCatalyst (13, 1)]
		[Export ("requestAlwaysAuthorization")]
		void RequestAlwaysAuthorization ();

		/// <summary>Starts generating events in response to visits.</summary>
		///         <remarks>To be added.</remarks>
		[NoTV]
		[MacCatalyst (13, 1)]
		[Export ("startMonitoringVisits")]
		void StartMonitoringVisits ();

		/// <summary>Stops generating events in response to visits.</summary>
		///         <remarks>To be added.</remarks>
		[NoTV]
		[MacCatalyst (13, 1)]
		[Export ("stopMonitoringVisits")]
		void StopMonitoringVisits ();

		/// <summary>Gets or sets a Boolean value that controls whether the application will respond to location updates while it is suspended.</summary>
		///         <value>To be added.</value>
		///         <remarks>To be added.</remarks>
		[NoTV]
		[MacCatalyst (13, 1)]
		[Export ("allowsBackgroundLocationUpdates")]
		bool AllowsBackgroundLocationUpdates { get; set; }

		/// <summary>To be added.</summary>
		///         <value>To be added.</value>
		///         <remarks>To be added.</remarks>
		[NoTV]
		[MacCatalyst (13, 1)]
		[Export ("showsBackgroundLocationIndicator")]
		bool ShowsBackgroundLocationIndicator { get; set; }

		/// <summary>Requests the current location.</summary>
		///         <remarks>To be added.</remarks>
		[MacCatalyst (13, 1)]
		[Export ("requestLocation")]
		void RequestLocation ();

		[TV (14, 0), iOS (14, 0)]
		[MacCatalyst (14, 0)]
		[Export ("accuracyAuthorization")]
		CLAccuracyAuthorization AccuracyAuthorization { get; }

		[Async]
		[TV (14, 0), iOS (14, 0)]
		[MacCatalyst (14, 0)]
		[Export ("requestTemporaryFullAccuracyAuthorizationWithPurposeKey:completion:")]
		void RequestTemporaryFullAccuracyAuthorization (string purposeKey, [NullAllowed] Action<NSError> completion);

		[TV (14, 0), iOS (14, 0)]
		[MacCatalyst (14, 0)]
		[Export ("requestTemporaryFullAccuracyAuthorizationWithPurposeKey:")]
		void RequestTemporaryFullAccuracyAuthorization (string purposeKey);

		[NoTV, iOS (14, 0)]
		[MacCatalyst (14, 0)]
		[Export ("authorizedForWidgetUpdates")]
		bool IsAuthorizedForWidgetUpdates { [Bind ("isAuthorizedForWidgetUpdates")] get; }

		[Async]
		[NoTV, NoMac, NoMacCatalyst]
		[iOS (15, 0)]
		[Export ("startMonitoringLocationPushesWithCompletion:")]
		void StartMonitoringLocationPushes ([NullAllowed] Action<NSData, NSError> completion);

		[NoTV, NoMac, NoMacCatalyst]
		[iOS (15, 0)]
		[Export ("stopMonitoringLocationPushes")]
		void StopMonitoringLocationPushes ();

		[NoTV, NoMac, NoiOS, NoMacCatalyst]
		[Export ("requestHistoricalLocationsWithPurposeKey:sampleCount:completionHandler:")]
		void RequestHistoricalLocations (string purposeKey, nint sampleCount, RequestHistoricalLocationsCompletionHandler handler);
	}

	interface ICLLocationManagerDelegate { }

	/// <summary>Interface representing the required methods (if any) of the protocol <see cref="CoreLocation.CLLocationManagerDelegate" />.</summary>
	/// <remarks>
	///       <para>This interface contains the required methods (if any) from the protocol defined by <see cref="CoreLocation.CLLocationManagerDelegate" />.</para>
	///       <para>If developers create classes that implement this interface, the implementation methods will automatically be exported to Objective-C with the matching signature from the method defined in the <see cref="CoreLocation.CLLocationManagerDelegate" /> protocol.</para>
	///       <para>Optional methods (if any) are provided by the <see cref="CoreLocation.CLLocationManagerDelegate_Extensions" /> class as extension methods to the interface, allowing developers to invoke any optional methods on the protocol.</para>
	///     </remarks>
	[BaseType (typeof (NSObject))]
	[Model]
	[Protocol]
	partial interface CLLocationManagerDelegate {
		/// <param name="manager">The <see cref="CoreLocation.CLLocationManager" /> for which <c>this</c> is the delegate object.</param>
		///         <param name="newLocation">To be added.</param>
		///         <param name="oldLocation">To be added.</param>
		///         <summary>Developers should not use this deprecated method. </summary>
		///         <remarks>To be added.</remarks>
		[NoTV]
		[Deprecated (PlatformName.iOS, 6, 0)]
		[MacCatalyst (13, 1)]
		[Deprecated (PlatformName.MacCatalyst, 13, 1)]
		[Export ("locationManager:didUpdateToLocation:fromLocation:"), EventArgs ("CLLocationUpdated")]
		void UpdatedLocation (CLLocationManager manager, CLLocation newLocation, CLLocation oldLocation);

		/// <param name="manager">The <see cref="CoreLocation.CLLocationManager" /> for which <c>this</c> is the delegate object.</param>
		///         <param name="newHeading">The new heading.</param>
		///         <summary>The device's heading has been updated.</summary>
		///         <remarks>To be added.</remarks>
		[NoTV]
		[MacCatalyst (13, 1)]
		[Export ("locationManager:didUpdateHeading:"), EventArgs ("CLHeadingUpdated")]
		void UpdatedHeading (CLLocationManager manager, CLHeading newHeading);

		/// <param name="manager">The <see cref="CoreLocation.CLLocationManager" /> for which <c>this</c> is the delegate object.</param>
		///         <summary>The system believes that the magnetometer should be calibrated.</summary>
		///         <returns>Return <see langword="true" /> to allow the calibration dialog.</returns>
		///         <remarks>
		///           <para>This method will be executed when the system believes that the magnetometer (compass) requires calibration, either because it has not been calibrated recently or because a large change in the local magnetic field was detected.</para>
		///           <para>Application developers may override this method to return <see langword="false" />, in which case the calibration dialog will not appear.</para>
		///         </remarks>
		[NoTV]
		[MacCatalyst (13, 1)]
		[Export ("locationManagerShouldDisplayHeadingCalibration:"), DelegateName ("CLLocationManagerEventArgs"), DefaultValue (true)]
		bool ShouldDisplayHeadingCalibration (CLLocationManager manager);

		/// <param name="manager">The <see cref="CoreLocation.CLLocationManager" /> for which <c>this</c> is the delegate object.</param>
		///         <param name="error">The error that occurred.</param>
		///         <summary>A failure occurred while updating locations.</summary>
		///         <remarks>To be added.</remarks>
		[Export ("locationManager:didFailWithError:"), EventArgs ("NSError", true)]
		void Failed (CLLocationManager manager, NSError error);

		/// <param name="manager">The <see cref="CoreLocation.CLLocationManager" /> for which <c>this</c> is the delegate object.</param>
		///         <param name="region">The region entered.</param>
		///         <summary>Called when the device enters a monitored region.</summary>
		///         <remarks>
		///         </remarks>
		[NoTV]
		[MacCatalyst (13, 1)]
		[Export ("locationManager:didEnterRegion:"), EventArgs ("CLRegion")]
		void RegionEntered (CLLocationManager manager, CLRegion region);

		/// <param name="manager">The <see cref="CoreLocation.CLLocationManager" /> for which <c>this</c> is the delegate object.</param>
		///         <param name="region">The region left.</param>
		///         <summary>Called when the device leaves a monitored region.</summary>
		///         <remarks>To be added.</remarks>
		[NoTV]
		[MacCatalyst (13, 1)]
		[Export ("locationManager:didExitRegion:"), EventArgs ("CLRegion")]
		void RegionLeft (CLLocationManager manager, CLRegion region);

		/// <param name="manager">The <see cref="CoreLocation.CLLocationManager" /> for which <c>this</c> is the delegate object.</param>
		///         <param name="region">To be added.</param>
		///         <param name="error">The cause of the failure.</param>
		///         <summary>Monitoring <paramref name="region" /> failed.</summary>
		///         <remarks>To be added.</remarks>
		[NoTV]
		[MacCatalyst (13, 1)]
		[Export ("locationManager:monitoringDidFailForRegion:withError:"), EventArgs ("CLRegionError")]
		void MonitoringFailed (CLLocationManager manager, [NullAllowed] CLRegion region, NSError error);

		/// <param name="manager">The <see cref="CoreLocation.CLLocationManager" /> for which <c>this</c> is the delegate object.</param>
		///         <param name="region">To be added.</param>
		///         <summary>Monitoring began for <paramref name="region" />.</summary>
		///         <remarks>To be added.</remarks>
		[NoTV]
		[MacCatalyst (13, 1)]
		[Export ("locationManager:didStartMonitoringForRegion:"), EventArgs ("CLRegion")]
		void DidStartMonitoringForRegion (CLLocationManager manager, CLRegion region);

		/// <param name="manager">The <see cref="CoreLocation.CLLocationManager" /> for which <c>this</c> is the delegate object.</param>
		///         <param name="state">The new state of the region.</param>
		///         <param name="region">To be added.</param>
		///         <summary>The <paramref name="state" /> of the <paramref name="region" /> has changed.</summary>
		///         <remarks>To be added.</remarks>
		[NoTV]
		[MacCatalyst (13, 1)]
		[Export ("locationManager:didDetermineState:forRegion:"), EventArgs ("CLRegionStateDetermined")]
		void DidDetermineState (CLLocationManager manager, CLRegionState state, CLRegion region);

		/// <param name="manager">The <see cref="CoreLocation.CLLocationManager" /> for which <c>this</c> is the delegate object.</param>
		///         <param name="beacons">The ranged <see cref="CoreLocation.CLBeacon" />s.</param>
		///         <param name="region">To be added.</param>
		///         <summary>Range information was generated for <paramref name="beacons" /> in <paramref name="region" />.</summary>
		///         <remarks>To be added.</remarks>
		[NoTV]
		[NoMac]
		[Deprecated (PlatformName.iOS, 13, 0, message: "Use 'DidRangeBeaconsSatisfyingConstraint' instead.")]
		[MacCatalyst (13, 1)]
		[Deprecated (PlatformName.MacCatalyst, 13, 1, message: "Use 'DidRangeBeaconsSatisfyingConstraint' instead.")]
		[Export ("locationManager:didRangeBeacons:inRegion:"), EventArgs ("CLRegionBeaconsRanged")]
		void DidRangeBeacons (CLLocationManager manager, CLBeacon [] beacons, CLBeaconRegion region);

		[NoTV, iOS (13, 0)]
		[MacCatalyst (13, 1)]
		[Export ("locationManager:didRangeBeacons:satisfyingConstraint:")]
		[EventArgs ("CLRegionBeaconsConstraintRanged")]
		void DidRangeBeaconsSatisfyingConstraint (CLLocationManager manager, CLBeacon [] beacons, CLBeaconIdentityConstraint beaconConstraint);

		/// <param name="manager">The <see cref="CoreLocation.CLLocationManager" /> for which <c>this</c> is the delegate object.</param>
		///         <param name="region">To be added.</param>
		///         <param name="error">To be added.</param>
		///         <summary>
		///           <paramref name="error" /> occurred while attempting to get range data from <paramref name="region" />.</summary>
		///         <remarks>To be added.</remarks>
		[NoTV]
		[NoMac]
		[Deprecated (PlatformName.iOS, 13, 0, message: "Use 'DidFailRangingBeacons' instead.")]
		[MacCatalyst (13, 1)]
		[Deprecated (PlatformName.MacCatalyst, 13, 1, message: "Use 'DidFailRangingBeacons' instead.")]
		[Export ("locationManager:rangingBeaconsDidFailForRegion:withError:"), EventArgs ("CLRegionBeaconsFailed")]
		void RangingBeaconsDidFailForRegion (CLLocationManager manager, CLBeaconRegion region, NSError error);

		[NoTV, iOS (13, 0)]
		[MacCatalyst (13, 1)]
		[Export ("locationManager:didFailRangingBeaconsForConstraint:error:")]
		[EventArgs ("CLRegionBeaconsConstraintFailed")]
		void DidFailRangingBeacons (CLLocationManager manager, CLBeaconIdentityConstraint beaconConstraint, NSError error);

		/// <param name="manager">To be added.</param>
		///         <param name="visit">To be added.</param>
		///         <summary>To be added.</summary>
		///         <remarks>To be added.</remarks>
		[NoTV]
		[MacCatalyst (13, 1)]
		[Export ("locationManager:didVisit:"), EventArgs ("CLVisited")]
		void DidVisit (CLLocationManager manager, CLVisit visit);

		/// <param name="manager">The <see cref="CoreLocation.CLLocationManager" /> for which <c>this</c> is the delegate object.</param>
		///         <param name="status">The new authorization status of the application.</param>
		///         <summary>The authorization status of the application has changed.</summary>
		///         <remarks>To be added.</remarks>
		[Deprecated (PlatformName.iOS, 14, 0, message: "Use 'DidChangeAuthorization' instead.")]
		[Deprecated (PlatformName.MacOSX, 11, 0, message: "Use 'DidChangeAuthorization' instead.")]
		[Deprecated (PlatformName.TvOS, 14, 0, message: "Use 'DidChangeAuthorization' instead.")]
		[Deprecated (PlatformName.MacCatalyst, 14, 0, message: "Use 'DidChangeAuthorization' instead.")]
		[Export ("locationManager:didChangeAuthorizationStatus:"), EventArgs ("CLAuthorizationChanged")]
		void AuthorizationChanged (CLLocationManager manager, CLAuthorizationStatus status);

		/// <param name="manager">The <see cref="CoreLocation.CLLocationManager" /> for which <c>this</c> is the delegate object.</param>
		///         <param name="locations">To be added.</param>
		///         <summary>The device has generated <paramref name="locations" /> updates.</summary>
		///         <remarks>To be added.</remarks>
		[Export ("locationManager:didUpdateLocations:"), EventArgs ("CLLocationsUpdated")]
		void LocationsUpdated (CLLocationManager manager, CLLocation [] locations);

		/// <param name="manager">The <see cref="CoreLocation.CLLocationManager" /> for which <c>this</c> is the delegate object.</param>
		///         <summary>Location updating has been paused.</summary>
		///         <remarks>To be added.</remarks>
		[NoTV]
		[MacCatalyst (13, 1)]
		[Export ("locationManagerDidPauseLocationUpdates:"), EventArgs ("")]
		void LocationUpdatesPaused (CLLocationManager manager);

		/// <param name="manager">The <see cref="CoreLocation.CLLocationManager" /> for which <c>this</c> is the delegate object.</param>
		///         <summary>Location updating has restarted after pausing.</summary>
		///         <remarks>To be added.</remarks>
		[NoTV]
		[MacCatalyst (13, 1)]
		[Export ("locationManagerDidResumeLocationUpdates:"), EventArgs ("")]
		void LocationUpdatesResumed (CLLocationManager manager);

		/// <param name="manager">The <see cref="CoreLocation.CLLocationManager" /> for which <c>this</c> is the delegate object.</param>
		///         <param name="error">The reason deferred updates are no longer available.</param>
		///         <summary>Location updates will no longer be deferred.</summary>
		///         <remarks>To be added.</remarks>
		[NoTV]
		[MacCatalyst (13, 1)]
		[Export ("locationManager:didFinishDeferredUpdatesWithError:"), EventArgs ("NSError", true)]
		void DeferredUpdatesFinished (CLLocationManager manager, [NullAllowed] NSError error);

		[TV (14, 0), iOS (14, 0)]
		[MacCatalyst (14, 0)]
		[Export ("locationManagerDidChangeAuthorization:")]
		void DidChangeAuthorization (CLLocationManager manager);

	}

	/// <summary>A class whose static members define constants relating to filtering and maximum distance.</summary>
	/// <remarks>To be added.</remarks>
	[Static]
	partial interface CLLocationDistance {

		/// <summary>When used with <see cref="CoreLocation.CLLocationManager.DistanceFilter" />, indicates that the maximum distance filter be used.</summary>
		///         <value>
		///         </value>
		///         <remarks>To be added.</remarks>
		[MacCatalyst (13, 1)]
		[Field ("CLLocationDistanceMax")]
		double MaxDistance { get; }

		/// <summary>When used with <see cref="CoreLocation.CLLocationManager.DistanceFilter" />, indicates that no distance filter be used.</summary>
		///         <value>
		///         </value>
		///         <remarks>To be added.</remarks>
		[Field ("kCLDistanceFilterNone")]
		double FilterNone { get; }
	}

	/// <summary>The base class for trackable geographical regions.</summary>
	/// <remarks>
	///       <para>Application developers should use a subtype, either <see cref="CoreLocation.CLCircularRegion" /> or <see cref="CoreLocation.CLBeaconRegion" />:</para>
	///       <para>
	///         <img href="~/CoreLocation/_images/CoreLocation.CLBeacon.Hierarchy.png" alt="Class diagram showing CLBeaconRegion and CLCircularRegion are subclasses of CLRegion" />
	///       </para>
	///     </remarks>
	/// <related type="externalDocumentation" href="https://developer.apple.com/library/ios/documentation/CoreLocation/Reference/CLRegion_class/index.html">Apple documentation for <c>CLRegion</c></related>
	[BaseType (typeof (NSObject))]
	[DisableDefaultCtor] // will crash, see CoreLocation.cs for compatibility stubs
	partial interface CLRegion : NSSecureCoding, NSCopying {
		/// <summary>The region's center</summary>
		///         <value>To be added.</value>
		///         <remarks>To be added.</remarks>
		[NoTV]
		[Deprecated (PlatformName.iOS, 7, 0, message: "Use 'CLCircularRegion' instead.")]
		[Deprecated (PlatformName.MacOSX, 10, 10, message: "Use 'CLCircularRegion' instead.")]
		[MacCatalyst (13, 1)]
		[Deprecated (PlatformName.MacCatalyst, 13, 1, message: "Use 'CLCircularRegion' instead.")]
		[Export ("center")]
		CLLocationCoordinate2D Center { get; }

		/// <summary>Radius in meters of the region.</summary>
		///         <value>To be added.</value>
		///         <remarks>To be added.</remarks>
		[NoTV]
		[Deprecated (PlatformName.iOS, 7, 0, message: "Use 'CLCircularRegion' instead.")]
		[Deprecated (PlatformName.MacOSX, 10, 10, message: "Use 'CLCircularRegion' instead.")]
		[MacCatalyst (13, 1)]
		[Deprecated (PlatformName.MacCatalyst, 13, 1, message: "Use 'CLCircularRegion' instead.")]
		[Export ("radius")]
		double Radius { get; }

		/// <summary>The unique identifier that was used when the region was created.</summary>
		///         <value>To be added.</value>
		///         <remarks>To be added.</remarks>
		[Export ("identifier")]
		string Identifier { get; }

		/// <param name="center">The center of the circle</param>
		/// <param name="radius">The radius of the circle in meters</param>
		/// <param name="identifier">A unique identifier assigned by your application.</param>
		/// <summary>Developers should not use this deprecated constructor. Developers should use 'CLCircularRegion' instead.</summary>
		/// <remarks>To be added.</remarks>
		[NoTV]
		[Deprecated (PlatformName.iOS, 7, 0, message: "Use 'CLCircularRegion' instead.")]
		[Deprecated (PlatformName.MacOSX, 10, 10, message: "Use 'CLCircularRegion' instead.")]
		[MacCatalyst (13, 1)]
		[Deprecated (PlatformName.MacCatalyst, 13, 1, message: "Use 'CLCircularRegion' instead.")]
		[Export ("initCircularRegionWithCenter:radius:identifier:")]
		NativeHandle Constructor (CLLocationCoordinate2D center, double radius, string identifier);

		/// <param name="coordinate">The coordinate to probe.</param>
		///         <summary>Probes whether the given location is contained within the region.</summary>
		///         <returns />
		///         <remarks>To be added.</remarks>
		[NoTV]
		[Deprecated (PlatformName.iOS, 7, 0, message: "Use 'CLCircularRegion' instead.")]
		[Deprecated (PlatformName.MacOSX, 10, 10, message: "Use 'CLCircularRegion' instead.")]
		[MacCatalyst (13, 1)]
		[Deprecated (PlatformName.MacCatalyst, 13, 1, message: "Use 'CLCircularRegion' instead.")]
		[Export ("containsCoordinate:")]
		bool Contains (CLLocationCoordinate2D coordinate);

		/// <summary>Whether the app should be notified when the device enters the region.</summary>
		///         <value>To be added.</value>
		///         <remarks>To be added.</remarks>
		[Export ("notifyOnEntry", ArgumentSemantic.Assign)]
		[MacCatalyst (13, 1)]
		bool NotifyOnEntry { get; set; }

		/// <summary>Whether the app should be notified when the device leaves the region.</summary>
		///         <value>To be added.</value>
		///         <remarks>To be added.</remarks>
		[Export ("notifyOnExit", ArgumentSemantic.Assign)]
		[MacCatalyst (13, 1)]
		bool NotifyOnExit { get; set; }
	}

	[BaseType (typeof (NSObject))]
	[DisableDefaultCtor] // will crash, see CoreLocation.cs for compatibility stubs
	interface CLPlacemark : NSSecureCoding, NSCopying {
		/// <include file="../docs/api/CoreLocation/CLPlacemark.xml" path="/Documentation/Docs[@DocId='P:CoreLocation.CLPlacemark.AddressDictionary']/*" />
		[Deprecated (PlatformName.iOS, 11, 0, message: "Use 'CLPlacemark' properties to access data.")]
		[Deprecated (PlatformName.TvOS, 11, 0, message: "Use 'CLPlacemark' properties to access data.")]
		[Deprecated (PlatformName.MacOSX, 10, 13, message: "Use 'CLPlacemark' properties to access data.")]
		[Deprecated (PlatformName.MacCatalyst, 13, 1, message: "Use 'CLPlacemark' properties to access data.")]
		[NullAllowed, Export ("addressDictionary", ArgumentSemantic.Copy)]
		NSDictionary AddressDictionary { get; }

		/// <summary>The state or province. May be spelled out or abbreviated.</summary>
		///         <value>To be added.</value>
		///         <remarks>To be added.</remarks>
		[NullAllowed, Export ("administrativeArea")]
		string AdministrativeArea { get; }

		/// <summary>A region, smaller than the <see cref="CoreLocation.CLPlacemark.AdministrativeArea" />. Often, the county in which the <see cref="CoreLocation.CLPlacemark" /> is located.</summary>
		///         <value>To be added.</value>
		///         <remarks>To be added.</remarks>
		[NullAllowed, Export ("subAdministrativeArea")]
		string SubAdministrativeArea { get; }

		/// <summary>A small area, such as a neighborhood or landmark name, associated with the <see cref="CoreLocation.CLPlacemark" />.</summary>
		///         <value>To be added.</value>
		///         <remarks>To be added.</remarks>
		[NullAllowed, Export ("subLocality")]
		string SubLocality { get; }

		/// <summary>The city or town associated with the <see cref="CoreLocation.CLPlacemark" />.</summary>
		///         <value>To be added.</value>
		///         <remarks>To be added.</remarks>
		[NullAllowed, Export ("locality")]
		string Locality { get; }

		/// <summary>The name of the country associated with the placemark.</summary>
		///         <value>The name is spelled out, not an ISO-3166 code (e.g., "United States" not "US").</value>
		///         <remarks>To be added.</remarks>
		///         <altmember cref="CoreLocation.CLPlacemark.IsoCountryCode" />
		[NullAllowed, Export ("country")]
		string Country { get; }

		/// <summary>The postal code associated with the <see cref="CoreLocation.CLPlacemark" />.</summary>
		///         <value>To be added.</value>
		///         <remarks>To be added.</remarks>
		[NullAllowed, Export ("postalCode")]
		string PostalCode { get; }

		/// <summary>The street address associated with the <see cref="CoreLocation.CLPlacemark" />.</summary>
		///         <value>To be added.</value>
		///         <remarks>To be added.</remarks>
		[NullAllowed, Export ("thoroughfare")]
		string Thoroughfare { get; }

		/// <summary>The finest-grained street information, such as the street number of an address.</summary>
		///         <value>To be added.</value>
		///         <remarks>To be added.</remarks>
		[NullAllowed, Export ("subThoroughfare")]
		string SubThoroughfare { get; }

		/// <summary>The ISO 3166 Code associated with the <see cref="CoreLocation.CLPlacemark" />.</summary>
		///         <value>To be added.</value>
		///         <remarks>To be added.</remarks>
		///         <altmember cref="CoreLocation.CLPlacemark.Country" />
		[NullAllowed, Export ("ISOcountryCode")]
		string IsoCountryCode { get; }

		/// <summary>An array of relevant areas of interest (large parks, miltary bases, attractions, etc).</summary>
		///         <value>To be added.</value>
		///         <remarks>To be added.</remarks>
		[NullAllowed, Export ("areasOfInterest")]
		string [] AreasOfInterest { get; }

		[Export ("initWithPlacemark:")]
		NativeHandle Constructor (CLPlacemark placemark);

		/// <summary>The name of the lake, river, or other waterway associated with the <see cref="CoreLocation.CLPlacemark" />.</summary>
		///         <value>To be added.</value>
		///         <remarks>To be added.</remarks>
		[NullAllowed, Export ("inlandWater")]
		string InlandWater { get; }

		/// <summary>The location (contains latitude and longitude) of the <see cref="CoreLocation.CLPlacemark" />.</summary>
		///         <value>To be added.</value>
		///         <remarks>To be added.</remarks>
		[NullAllowed, Export ("location", ArgumentSemantic.Copy)]
		CLLocation Location { get; }

		/// <summary>The name of the <see cref="CoreLocation.CLPlacemark" />.</summary>
		///         <value>To be added.</value>
		///         <remarks>To be added.</remarks>
		[NullAllowed, Export ("name")]
		string Name { get; }

		/// <summary>The name of the ocean associated with the <see cref="CoreLocation.CLPlacemark" />.</summary>
		///         <value>To be added.</value>
		///         <remarks>To be added.</remarks>
		[NullAllowed, Export ("ocean")]
		string Ocean { get; }

		/// <summary>The geographic region associated with the <see cref="CoreLocation.CLPlacemark" />.</summary>
		///         <value>To be added.</value>
		///         <remarks>
		///           <para>The region returned will typically be a <see cref="CoreLocation.CLCircularRegion" /> centered on the placemark and with a <see cref="CoreLocation.CLCircularRegion.Radius" /> encompassing the region.</para>
		///         </remarks>
		[NullAllowed, Export ("region", ArgumentSemantic.Copy)]
		CLRegion Region { get; }

		/// <summary>Gets or sets the time zone in which the place mark resides.</summary>
		///         <value>To be added.</value>
		///         <remarks>To be added.</remarks>
		[NullAllowed, Export ("timeZone")]
		[MacCatalyst (13, 1)]
		NSTimeZone TimeZone { get; }

		// From CLPlacemark (ContactsAdditions) category.
		/// <summary>To be added.</summary>
		///         <value>
		///           <para>(More documentation for this node is coming)</para>
		///           <para tool="nullallowed">This value can be <see langword="null" />.</para>
		///         </value>
		///         <remarks>To be added.</remarks>
		[NoTV]
		[MacCatalyst (13, 1)]
		[NullAllowed, Export ("postalAddress")]
		CNPostalAddress PostalAddress { get; }
	}

	/// <summary>A <see cref="CoreLocation.CLRegion" /> defined by a center and a radius (in meters).</summary>
	/// <remarks>To be added.</remarks>
	/// <related type="externalDocumentation" href="https://developer.apple.com/library/ios/documentation/CoreLocation/Reference/CLCircularRegion_class/index.html">Apple documentation for <c>CLCircularRegion</c></related>
	[MacCatalyst (13, 1)]
	[Obsoleted (PlatformName.MacOSX, 14, 0, message: "Use 'CLCircularGeographicCondition' instead.")]
	[Obsoleted (PlatformName.iOS, 17, 0, message: "Use 'CLCircularGeographicCondition' instead.")]
	[Obsoleted (PlatformName.TvOS, 17, 0, message: "Use 'CLCircularGeographicCondition' instead.")]
	[BaseType (typeof (CLRegion))]
#if MONOMAC
	[DisableDefaultCtor]
#endif
	partial interface CLCircularRegion {

		/// <param name="center">The center of the region.</param>
		/// <param name="radius">The radius of the region, in meters.</param>
		/// <param name="identifier">The name of the region.</param>
		/// <summary>Constructor that produces a circular region called <paramref name="identifier" /> with a particular <paramref name="center" /> of <paramref name="radius" /> (in meters).</summary>
		/// <remarks>To be added.</remarks>
		[Export ("initWithCenter:radius:identifier:")]
		NativeHandle Constructor (CLLocationCoordinate2D center, double radius, string identifier);

		/// <summary>The center of the circular region.</summary>
		///         <value>To be added.</value>
		///         <remarks>To be added.</remarks>
		[Export ("center")]
		CLLocationCoordinate2D Center { get; }

		/// <summary>The radius of the circular region, in meters.</summary>
		///         <value>To be added.</value>
		///         <remarks>To be added.</remarks>
		[Export ("radius")]
		double Radius { get; }

		/// <param name="coordinate">To be added.</param>
		///         <summary>Returns <see langword="true" /> if <paramref name="coordinate" /> is within the region.</summary>
		///         <returns>To be added.</returns>
		///         <remarks>To be added.</remarks>
		[Export ("containsCoordinate:")]
		bool ContainsCoordinate (CLLocationCoordinate2D coordinate);
	}

	/// <summary>CoreLocation region determined by an iBeacon.</summary>
	///     <remarks>
	///       <para>
	/// 	Regions created with CLBeaconRegion can be added to a
	/// 	CoreLocation location manager (see <see cref="CoreLocation.CLLocationManager" />) to
	/// 	monitor when the device gets close to an iBeacon.
	/// 
	///       </para>
	///     </remarks>
	///     <related type="externalDocumentation" href="https://developer.apple.com/library/ios/documentation/CoreLocation/Reference/CLBeaconRegion_class/index.html">Apple documentation for <c>CLBeaconRegion</c></related>
	[NoTV]
	[MacCatalyst (13, 1)]
	[Deprecated (PlatformName.MacOSX, 14, 0, message: "Use 'CLBeaconIdentityCondition' instead.")]
	[Deprecated (PlatformName.iOS, 17, 0, message: "Use 'CLBeaconIdentityCondition' instead.")]
	[Deprecated (PlatformName.MacCatalyst, 17, 0, message: "Use 'CLBeaconIdentityCondition' instead.")]
	[BaseType (typeof (CLRegion))]
	[DisableDefaultCtor] // nil-Handle on iOS8 if 'init' is used
	partial interface CLBeaconRegion {

		/// <param name="proximityUuid">The unique ID of the iBeacons of interest.</param>
		/// <param name="identifier">The name of the region to be created.</param>
		/// <summary>Constructor that produces a region identified by <paramref name="identifier" /> that reports iBeacons associated with the <paramref name="proximityUuid" />.</summary>
		[Internal]
		[Deprecated (PlatformName.iOS, 13, 0, message: "Use the 'Create' method or the constructor using 'CLBeaconIdentityConstraint' instead.")]
		[MacCatalyst (13, 1)]
		[Deprecated (PlatformName.MacCatalyst, 13, 1, message: "Use the 'Create' method or the constructor using 'CLBeaconIdentityConstraint' instead.")]
		[Export ("initWithProximityUUID:identifier:")]
		NativeHandle _InitWithProximityUuid (NSUuid proximityUuid, string identifier);

		[iOS (13, 0)]
		[MacCatalyst (13, 1)]
		[Internal] // signature conflict with deprecated API
		[Export ("initWithUUID:identifier:")]
		IntPtr _InitWithUuid (NSUuid uuid, string identifier);

		/// <param name="proximityUuid">The unique ID of the iBeacons of interest.</param>
		/// <param name="major">Can be used by the app developer for any purpose.</param>
		/// <param name="identifier">The name of the region to be created.</param>
		/// <summary>Constructor that produces a region identified by <paramref name="identifier" /> that reports iBeacons associated with the <paramref name="proximityUuid" /> and that assigns the <see cref="CoreLocation.CLBeaconRegion.Major" /> property.</summary>
		[Internal]
		[Deprecated (PlatformName.iOS, 13, 0, message: "Use the 'Create' method or the constructor using 'CLBeaconIdentityConstraint' instead.")]
		[MacCatalyst (13, 1)]
		[Deprecated (PlatformName.MacCatalyst, 13, 1, message: "Use the 'Create' method or the constructor using 'CLBeaconIdentityConstraint' instead.")]
		[Export ("initWithProximityUUID:major:identifier:")]
		NativeHandle _InitWithProximityUuid (NSUuid proximityUuid, ushort major, string identifier);

		[iOS (13, 0)]
		[MacCatalyst (13, 1)]
		[Internal] // signature conflict with deprecated API
		[Export ("initWithUUID:major:identifier:")]
		IntPtr _InitWithUuid (NSUuid uuid, ushort major, string identifier);

		/// <param name="proximityUuid">The unique ID of the iBeacons of interest.</param>
		/// <param name="major">Can be used by the app developer for any purpose.</param>
		/// <param name="minor">Can be used by the app developer for any purpose.</param>
		/// <param name="identifier">The name of the region to be created.</param>
		/// <summary>Constructor that produces a region identified by <paramref name="identifier" /> that reports iBeacons associated with the <paramref name="proximityUuid" /> and that assigns the <see cref="CoreLocation.CLBeaconRegion.Major" /> and <see cref="CoreLocation.CLBeaconRegion.Minor" /> properties.</summary>
		[Internal]
		[Deprecated (PlatformName.iOS, 13, 0, message: "Use the 'Create' method or the constructor using 'CLBeaconIdentityConstraint' instead.")]
		[MacCatalyst (13, 1)]
		[Deprecated (PlatformName.MacCatalyst, 13, 1, message: "Use the 'Create' method or the constructor using 'CLBeaconIdentityConstraint' instead.")]
		[Export ("initWithProximityUUID:major:minor:identifier:")]
		NativeHandle _InitWithProximityUuid (NSUuid proximityUuid, ushort major, ushort minor, string identifier);

		[iOS (13, 0)]
		[MacCatalyst (13, 1)]
		[Internal] // signature conflict with deprecated API
		[Export ("initWithUUID:major:minor:identifier:")]
		IntPtr _InitWithUuid (NSUuid uuid, ushort major, ushort minor, string identifier);

		[iOS (13, 0)]
		[MacCatalyst (13, 1)]
		[Export ("initWithBeaconIdentityConstraint:identifier:")]
		NativeHandle Constructor (CLBeaconIdentityConstraint beaconIdentityConstraint, string identifier);

		/// <param name="measuredPower">
		///           <para>The measured RSSI (signal strength) of the device, in decibels at 1M. Developers should pass <see langword="null" /> to use the device's default value.</para>
		///           <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
		///         </param>
		///         <summary>Gets data for use with <see cref="CoreBluetooth.CBPeripheralManager.StartAdvertising(Foundation.NSDictionary)" />.</summary>
		///         <returns>The result can be passed to <see cref="CoreBluetooth.CBPeripheralManager.StartAdvertising(Foundation.NSDictionary)" />.</returns>
		///         <remarks>
		///           <para>Retrieves the appropriate data required by <see cref="CoreBluetooth.CBPeripheralManager.StartAdvertising(Foundation.NSDictionary)" />.</para>
		///         </remarks>
		[Export ("peripheralDataWithMeasuredPower:")]
		NSMutableDictionary GetPeripheralData ([NullAllowed] NSNumber measuredPower);

		/// <summary>The UUID associated with the iBeacon.</summary>
		///         <value>To be added.</value>
		///         <remarks>
		///           <para>The UUID of an iBeacon instance will often be the same UUID used in other instances (for instance, a chain of stores might use a UUID associated with the chain, not with the specific store in which the user finds themselves ).</para>
		///         </remarks>
		[NoMac]
		[Deprecated (PlatformName.iOS, 13, 0, message: "Use 'Uuid' instead.")]
		[MacCatalyst (13, 1)]
		[Deprecated (PlatformName.MacCatalyst, 13, 1, message: "Use 'Uuid' instead.")]
		[Export ("proximityUUID", ArgumentSemantic.Copy)]
		NSUuid ProximityUuid { get; }

		[iOS (13, 0)]
		[MacCatalyst (13, 1)]
		[Export ("UUID", ArgumentSemantic.Copy)]
		NSUuid Uuid { get; }

		/// <summary>A number that can be used by the application developer for any purpose.</summary>
		///         <value>To be added.</value>
		///         <remarks>To be added.</remarks>
		[NullAllowed, Export ("major", ArgumentSemantic.Copy)]
		NSNumber Major { get; }

		/// <summary>A number that can be used by the application developer for any purpose.</summary>
		///         <value>To be added.</value>
		///         <remarks>To be added.</remarks>
		[NullAllowed, Export ("minor", ArgumentSemantic.Copy)]
		NSNumber Minor { get; }

		/// <summary>Controls whether the entry/leave events are displayed to the user when they turn on their display.</summary>
		///         <value>
		///         </value>
		///         <remarks>
		///         </remarks>
		[Export ("notifyEntryStateOnDisplay", ArgumentSemantic.Assign)]
		bool NotifyEntryStateOnDisplay { get; set; }

		[iOS (13, 0)]
		[MacCatalyst (13, 1)]
		[Export ("beaconIdentityConstraint", ArgumentSemantic.Copy)]
		CLBeaconIdentityConstraint BeaconIdentityConstraint { get; }
	}

	/// <include file="../docs/api/CoreLocation/CLBeacon.xml" path="/Documentation/Docs[@DocId='T:CoreLocation.CLBeacon']/*" />
	[NoTV]
	[MacCatalyst (13, 1)]
	[BaseType (typeof (NSObject))]
	partial interface CLBeacon : NSCopying, NSSecureCoding {

		/// <summary>The proximity ID of the beacon.</summary>
		///         <value>To be added.</value>
		///         <remarks>To be added.</remarks>
		[NoMac]
		[Deprecated (PlatformName.iOS, 13, 0, message: "Use 'Uuid' instead.")]
		[MacCatalyst (13, 1)]
		[Deprecated (PlatformName.MacCatalyst, 13, 1, message: "Use 'Uuid' instead.")]
		[Export ("proximityUUID", ArgumentSemantic.Copy)]
		NSUuid ProximityUuid { get; }

		[iOS (13, 0)]
		[MacCatalyst (13, 1)]
		[Export ("UUID", ArgumentSemantic.Copy)]
		NSUuid Uuid { get; }

		/// <summary>A number that can be used by the application developer for any purpose.</summary>
		///         <value>To be added.</value>
		///         <remarks>
		///           <para>This property, and <see cref="CoreLocation.CLBeacon.Minor" /> can be used by the application developer for any purpose. For example, a department store would have a chain-wide <see cref="CoreLocation.CLBeacon.ProximityUuid" /> but might store the store-number in <see cref="CoreLocation.CLBeacon.Major" /> and the department number in <see cref="CoreLocation.CLBeacon.Minor" />.</para>
		///         </remarks>
		[Export ("major", ArgumentSemantic.Copy)]
		NSNumber Major { get; }

		/// <summary>A number that can be used by the application developer for any purpose.</summary>
		///         <value>To be added.</value>
		///         <remarks>
		///           <para>This property, and <see cref="CoreLocation.CLBeacon.Major" /> can be used by the application developer for any purpose. For example, a department store would have a chain-wide <see cref="CoreLocation.CLBeacon.ProximityUuid" /> but might store the store-number in <see cref="CoreLocation.CLBeacon.Major" /> and the department number in <see cref="CoreLocation.CLBeacon.Minor" />.</para>
		///         </remarks>
		[Export ("minor", ArgumentSemantic.Copy)]
		NSNumber Minor { get; }

		/// <summary>The distance to the beacon.</summary>
		///         <value>To be added.</value>
		///         <remarks>To be added.</remarks>
		[Export ("proximity")]
		CLProximity Proximity { get; }

		/// <summary>The accuracy of <see cref="CoreLocation.CLBeacon.Proximity" />, in meters.</summary>
		///         <value>To be added.</value>
		///         <remarks>
		///           <para>Application developers should not use this value to try to indicate a precise location. It should be used to tell the difference between multiple beacons with the same <see cref="CoreLocation.CLBeacon.Proximity" /> value.</para>
		///           <para>Even if both the device and the beacon are stationary, this value may vary over time due to radio interference.</para>
		///         </remarks>
		[Export ("accuracy")]
		double Accuracy { get; }

		/// <summary>The average received signal strength, measured in decibels.</summary>
		///         <value>To be added.</value>
		///         <remarks>
		///           <para>The average RSSI value of those samples received from the beacon since the last time range (see <see cref="CoreLocation.CLBeacon.Proximity" />) was reported to the app.</para>
		///         </remarks>
		[Export ("rssi")]
		nint Rssi { get; }

		[iOS (13, 0)]
		[MacCatalyst (13, 1)]
		[Export ("timestamp", ArgumentSemantic.Copy)]
		NSDate Timestamp { get; }
	}

	/// <param name="placemarks">Returns null on error, otherwise the list of placemark locations.   Typically one, but could be more than one if the location is known by multiple names.</param>
	/// <param name="error">Error information.</param>
	/// <summary>A delegate that is the <c>completionHandler</c> in calls to <see cref="CoreLocation.CLGeocoder.GeocodePostalAddressAsync(Contacts.CNPostalAddress,Foundation.NSLocale)" />.</summary>
	/// <remarks>
	///     </remarks>
	delegate void CLGeocodeCompletionHandler (CLPlacemark [] placemarks, NSError error);

	/// <include file="../docs/api/CoreLocation/CLGeocoder.xml" path="/Documentation/Docs[@DocId='T:CoreLocation.CLGeocoder']/*" />
	[BaseType (typeof (NSObject))]
	interface CLGeocoder {
		/// <summary>Whether a geocoding request is currently being processed.</summary>
		///         <value>
		///           <see langword="true" /> if the <see cref="CoreLocation.CLGeocoder" /> is in the process of geocoding.</value>
		///         <remarks>To be added.</remarks>
		[Export ("isGeocoding")]
		bool Geocoding { get; }

		/// <param name="location">Location to look up.</param>
		///         <param name="completionHandler">Method to invoke when the reverse lookup has completed.</param>
		///         <summary>Requests a longitude/latitude to a human address.</summary>
		///         <remarks>
		///         </remarks>
		[Export ("reverseGeocodeLocation:completionHandler:")]
		[Async (XmlDocs = """
			<param name="location">To be added.</param>
			<summary>To be added.</summary>
			<returns>
			          <para>A task that represents the asynchronous ReverseGeocodeLocation operation.   The value of the TResult parameter is a <see cref="CoreLocation.CLGeocodeCompletionHandler" />.</para>
			        </returns>
			<remarks>To be added.</remarks>
			""")]
		void ReverseGeocodeLocation (CLLocation location, CLGeocodeCompletionHandler completionHandler);

		/// <param name="location">To be added.</param>
		///         <param name="locale">
		///           <para>To be added.</para>
		///           <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
		///         </param>
		///         <param name="completionHandler">To be added.</param>
		///         <summary>To be added.</summary>
		///         <remarks>To be added.</remarks>
		[MacCatalyst (13, 1)]
		[Export ("reverseGeocodeLocation:preferredLocale:completionHandler:")]
		[Async (XmlDocs = """
			<param name="location">To be added.</param>
			<param name="locale">To be added.</param>
			<summary>To be added.</summary>
			<returns>To be added.</returns>
			<remarks>To be added.</remarks>
			""")]
		void ReverseGeocodeLocation (CLLocation location, [NullAllowed] NSLocale locale, CLGeocodeCompletionHandler completionHandler);

		/// <param name="addressDictionary">Addressbook dictionary to submit</param>
		///         <param name="completionHandler">Method to invoke when the request completes.</param>
		///         <summary>Developers should not use this deprecated method. Developers should use 'GeocodeAddress (string, CLRegion, NSLocale, CLGeocodeCompletionHandler)' instead.</summary>
		///         <remarks>
		///         </remarks>
		[Deprecated (PlatformName.iOS, 11, 0, message: "Use 'GeocodeAddress (string, CLRegion, NSLocale, CLGeocodeCompletionHandler)' instead.")]
		[Deprecated (PlatformName.TvOS, 11, 0, message: "Use 'GeocodeAddress (string, CLRegion, NSLocale, CLGeocodeCompletionHandler)' instead.")]
		[Deprecated (PlatformName.MacOSX, 10, 13, message: "Use 'GeocodeAddress (string, CLRegion, NSLocale, CLGeocodeCompletionHandler)' instead.")]
		[Deprecated (PlatformName.MacCatalyst, 13, 1, message: "Use 'GeocodeAddress (string, CLRegion, NSLocale, CLGeocodeCompletionHandler)' instead.")]
		[Export ("geocodeAddressDictionary:completionHandler:")]
		[Async (XmlDocs = """
			<param name="addressDictionary">Addressbook dictionary to submit</param>
			<summary>Developers should not use this deprecated method. Developers should use 'GeocodeAddress (string, CLRegion, NSLocale, CLGeocodeCompletionHandler)' instead.</summary>
			<returns>
			          <para>A task that represents the asynchronous GeocodeAddress operation.   The value of the TResult parameter is a <see cref="CoreLocation.CLGeocodeCompletionHandler" />.</para>
			        </returns>
			<remarks>To be added.</remarks>
			""")]
		void GeocodeAddress (NSDictionary addressDictionary, CLGeocodeCompletionHandler completionHandler);

		/// <param name="addressString">Adress that you want to submit.</param>
		///         <param name="completionHandler">Method to invoke when the request completes.</param>
		///         <summary>Request a latitude/longitude location from a human readable address.</summary>
		///         <remarks>
		///         </remarks>
		[Export ("geocodeAddressString:completionHandler:")]
		[Async (XmlDocs = """
			<param name="addressString">To be added.</param>
			<summary>To be added.</summary>
			<returns>
			          <para>A task that represents the asynchronous GeocodeAddress operation.   The value of the TResult parameter is a <see cref="CoreLocation.CLGeocodeCompletionHandler" />.</para>
			        </returns>
			<remarks>
			          <example>
			            <code lang="csharp lang-csharp"><![CDATA[
			  var addressString = "2 Park Plaza, Boston, MA, USA 02116";
			  var geocoder = new CLGeocoder();
			  var taskCoding = geocoder.GeocodeAddressAsync(addressString);
			  taskCoding.ContinueWith((addresses) => {
			  	foreach(var address in addresses.Result)
			  	{
			  		Console.WriteLine(address);
			  	}
			  });              
			                ]]></code>
			          </example>
			        </remarks>
			""")]
		void GeocodeAddress (string addressString, CLGeocodeCompletionHandler completionHandler);

		/// <param name="addressString">Adress that you want to submit.</param>
		///         <param name="region">Region to limit the lookup for.</param>
		///         <param name="completionHandler">Method to invoke when the request completes.</param>
		///         <summary>Request a latitude/longitude location from a human readable address and region.</summary>
		///         <remarks>To be added.</remarks>
		[Export ("geocodeAddressString:inRegion:completionHandler:")]
		[Async (XmlDocs = """
			<param name="addressString">To be added.</param>
			<param name="region">To be added.</param>
			<summary>Request a latitude/longitude location from a human readable address and region.</summary>
			<returns>A Task that represents the asynchronous geocoding operation.</returns>
			<remarks>To be added.</remarks>
			""")]
		void GeocodeAddress (string addressString, [NullAllowed] CLRegion region, CLGeocodeCompletionHandler completionHandler);

		/// <param name="addressString">To be added.</param>
		///         <param name="region">
		///           <para>To be added.</para>
		///           <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
		///         </param>
		///         <param name="locale">
		///           <para>To be added.</para>
		///           <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
		///         </param>
		///         <param name="completionHandler">To be added.</param>
		///         <summary>To be added.</summary>
		///         <remarks>To be added.</remarks>
		[MacCatalyst (13, 1)]
		[Async (XmlDocs = """
			<param name="addressString">To be added.</param>
			<param name="region">To be added.</param>
			<param name="locale">To be added.</param>
			<summary>To be added.</summary>
			<returns>To be added.</returns>
			<remarks>To be added.</remarks>
			""")]
		[Export ("geocodeAddressString:inRegion:preferredLocale:completionHandler:")]
		void GeocodeAddress (string addressString, [NullAllowed] CLRegion region, [NullAllowed] NSLocale locale, CLGeocodeCompletionHandler completionHandler);

		/// <summary>Cancels the geocoding attempt.</summary>
		///         <remarks>To be added.</remarks>
		[Export ("cancelGeocode")]
		void CancelGeocode ();

		/// <param name="postalAddress">To be added.</param>
		///         <param name="completionHandler">To be added.</param>
		///         <summary>To be added.</summary>
		///         <remarks>To be added.</remarks>
		[NoTV]
		[MacCatalyst (13, 1)]
		[Export ("geocodePostalAddress:completionHandler:")]
		[Async (XmlDocs = """
			<param name="postalAddress">To be added.</param>
			<summary>To be added.</summary>
			<returns>
			          <para>A task that represents the asynchronous GeocodePostalAddress operation.   The value of the TResult parameter is a CoreLocation.CLGeocodeCompletionHandler.</para>
			        </returns>
			<remarks>
			          <para copied="true">The GeocodePostalAddressAsync method is suitable to be used with C# async by returning control to the caller with a Task representing the operation.</para>
			          <para copied="true">To be added.</para>
			        </remarks>
			""")]
		void GeocodePostalAddress (CNPostalAddress postalAddress, CLGeocodeCompletionHandler completionHandler);

		/// <param name="postalAddress">To be added.</param>
		///         <param name="locale">
		///           <para>To be added.</para>
		///           <para tool="nullallowed">This parameter can be <see langword="null" />.</para>
		///         </param>
		///         <param name="completionHandler">To be added.</param>
		///         <summary>To be added.</summary>
		///         <remarks>To be added.</remarks>
		[NoTV]
		[MacCatalyst (13, 1)]
		[Export ("geocodePostalAddress:preferredLocale:completionHandler:")]
		[Async (XmlDocs = """
			<param name="postalAddress">To be added.</param>
			<param name="locale">To be added.</param>
			<summary>To be added.</summary>
			<returns>To be added.</returns>
			<remarks>To be added.</remarks>
			""")]
		void GeocodePostalAddress (CNPostalAddress postalAddress, [NullAllowed] NSLocale locale, CLGeocodeCompletionHandler completionHandler);
	}

	/// <summary>Relates a location and radius with an arrival and departure time.</summary>
	///     
	///     <related type="externalDocumentation" href="https://developer.apple.com/library/ios/documentation/CoreLocation/Reference/CLVisit_class/index.html">Apple documentation for <c>CLVisit</c></related>
	[NoTV]
	[MacCatalyst (13, 1)]
	[BaseType (typeof (NSObject))]
	interface CLVisit : NSSecureCoding, NSCopying {

		/// <summary>To be added.</summary>
		///         <value>To be added.</value>
		///         <remarks>To be added.</remarks>
		[Export ("arrivalDate", ArgumentSemantic.Copy)]
		NSDate ArrivalDate { get; }

		/// <summary>To be added.</summary>
		///         <value>To be added.</value>
		///         <remarks>To be added.</remarks>
		[Export ("departureDate", ArgumentSemantic.Copy)]
		NSDate DepartureDate { get; }

		/// <summary>To be added.</summary>
		///         <value>To be added.</value>
		///         <remarks>To be added.</remarks>
		[Export ("coordinate")]
		CLLocationCoordinate2D Coordinate { get; }

		/// <summary>To be added.</summary>
		///         <value>To be added.</value>
		///         <remarks>To be added.</remarks>
		[Export ("horizontalAccuracy")]
		double HorizontalAccuracy { get; }
	}

	[NoTV, iOS (13, 0)]
	[MacCatalyst (13, 1)]
	[Deprecated (PlatformName.MacOSX, 14, 0, message: "Use 'CLBeaconIdentityCondition' instead.")]
	[Deprecated (PlatformName.iOS, 17, 0, message: "Use 'CLBeaconIdentityCondition' instead.")]
	[Deprecated (PlatformName.MacCatalyst, 17, 0, message: "Use 'CLBeaconIdentityCondition' instead.")]
	[BaseType (typeof (NSObject))]
	[DisableDefaultCtor] // NSInvalidArgumentException Reason: -[CLBeaconIdentityConstraint init]: unrecognized selector sent to instance 0x600001930300
	interface CLBeaconIdentityConstraint : NSCopying, NSSecureCoding {

		[Export ("initWithUUID:")]
		NativeHandle Constructor (NSUuid uuid);

		[Export ("initWithUUID:major:")]
		NativeHandle Constructor (NSUuid uuid, ushort major);

		[Export ("initWithUUID:major:minor:")]
		NativeHandle Constructor (NSUuid uuid, ushort major, ushort minor);

		[Export ("UUID", ArgumentSemantic.Copy)]
		NSUuid Uuid { get; }

		[NullAllowed, Export ("major", ArgumentSemantic.Copy)]
		[BindAs (typeof (short?))]
		NSNumber Major { get; }

		[NullAllowed, Export ("minor", ArgumentSemantic.Copy)]
		[BindAs (typeof (short?))]
		NSNumber Minor { get; }
	}

	[iOS (15, 0), NoTV, NoMacCatalyst, NoMac]
	[Protocol]
	interface CLLocationPushServiceExtension {
		[Abstract]
		[Export ("didReceiveLocationPushPayload:completion:")]
		void DidReceiveLocationPushPayload (NSDictionary<NSString, NSObject> payload, Action completion);

		[Export ("serviceExtensionWillTerminate")]
		void ServiceExtensionWillTerminate ();
	}

	[TV (15, 0), iOS (15, 0), MacCatalyst (15, 0)]
	[BaseType (typeof (NSObject))]
	interface CLLocationSourceInformation : NSCopying, NSSecureCoding {
		[Export ("initWithSoftwareSimulationState:andExternalAccessoryState:")]
		NativeHandle Constructor (bool isSoftware, bool isAccessory);

		[Export ("isSimulatedBySoftware")]
		bool IsSimulatedBySoftware { get; }

		[Export ("isProducedByAccessory")]
		bool IsProducedByAccessory { get; }
	}

	[TV (17, 0), Mac (14, 0), iOS (17, 0), MacCatalyst (17, 0)]
	[BaseType (typeof (NSObject))]
	interface CLUpdate {
		[Deprecated (PlatformName.iOS, 18, 0, message: "Use 'Stationary' instead.")]
		[Deprecated (PlatformName.MacCatalyst, 18, 0, message: "Use 'Stationary' instead.")]
		[Deprecated (PlatformName.TvOS, 18, 0, message: "Use 'Stationary' instead.")]
		[Deprecated (PlatformName.MacOSX, 15, 0, message: "Use 'Stationary' instead.")]
		[Export ("isStationary")]
		bool IsStationary { get; }

		[NullAllowed, Export ("location")]
		CLLocation Location { get; }

		[TV (18, 0), Mac (15, 0), iOS (18, 0), MacCatalyst (18, 0)]
		[Export ("authorizationDenied")]
		bool AuthorizationDenied { get; }

		[TV (18, 0), Mac (15, 0), iOS (18, 0), MacCatalyst (18, 0)]
		[Export ("authorizationDeniedGlobally")]
		bool AuthorizationDeniedGlobally { get; }

		[TV (18, 0), Mac (15, 0), iOS (18, 0), MacCatalyst (18, 0)]
		[Export ("authorizationRestricted")]
		bool AuthorizationRestricted { get; }

		[TV (18, 0), Mac (15, 0), iOS (18, 0), MacCatalyst (18, 0)]
		[Export ("stationary")]
		bool Stationary { get; }

		[TV (18, 0), Mac (15, 0), iOS (18, 0), MacCatalyst (18, 0)]
		[Export ("insufficientlyInUse")]
		bool InsufficientlyInUse { get; }

		[TV (18, 0), Mac (15, 0), iOS (18, 0), MacCatalyst (18, 0)]
		[Export ("locationUnavailable")]
		bool LocationUnavailable { get; }

		[TV (18, 0), Mac (15, 0), iOS (18, 0), MacCatalyst (18, 0)]
		[Export ("accuracyLimited")]
		bool AccuracyLimited { get; }

		[NoTV, Mac (15, 0), iOS (18, 0), MacCatalyst (18, 0)]
		[Export ("serviceSessionRequired")]
		bool ServiceSessionRequired { get; }

		[NoTV, Mac (15, 0), iOS (18, 0), MacCatalyst (18, 0)]
		[Export ("authorizationRequestInProgress")]
		bool AuthorizationRequestInProgress { get; }
	}

	[NoTV, Mac (14, 0), iOS (17, 0), MacCatalyst (17, 0)]
	[BaseType (typeof (NSObject))]
	[DisableDefaultCtor]
	interface CLMonitoringRecord : NSSecureCoding {
		[Export ("condition", ArgumentSemantic.Strong)]
		CLCondition Condition { get; }

		[Export ("lastEvent", ArgumentSemantic.Strong)]
		CLMonitoringEvent LastEvent { get; }
	}

	[NoTV, Mac (14, 0), iOS (17, 0), MacCatalyst (17, 0)]
	[BaseType (typeof (NSObject))]
	[DisableDefaultCtor]
	interface CLMonitoringEvent : NSSecureCoding {
		[Export ("identifier", ArgumentSemantic.Strong)]
		string Identifier { get; }

		[NullAllowed, Export ("refinement", ArgumentSemantic.Strong)]
		CLCondition Refinement { get; }

		[Export ("state")]
		CLMonitoringState State { get; }

		[Export ("date", ArgumentSemantic.Strong)]
		NSDate Date { get; }

		[NoTV, Mac (15, 0), iOS (18, 0), MacCatalyst (18, 0)]
		[Export ("authorizationDenied")]
		bool AuthorizationDenied { get; }

		[NoTV, Mac (15, 0), iOS (18, 0), MacCatalyst (18, 0)]
		[Export ("authorizationDeniedGlobally")]
		bool AuthorizationDeniedGlobally { get; }

		[NoTV, Mac (15, 0), iOS (18, 0), MacCatalyst (18, 0)]
		[Export ("authorizationRestricted")]
		bool AuthorizationRestricted { get; }

		[NoTV, Mac (15, 0), iOS (18, 0), MacCatalyst (18, 0)]
		[Export ("insufficientlyInUse")]
		bool InsufficientlyInUse { get; }

		[NoTV, Mac (15, 0), iOS (18, 0), MacCatalyst (18, 0)]
		[Export ("accuracyLimited")]
		bool AccuracyLimited { get; }

		[NoTV, Mac (15, 0), iOS (18, 0), MacCatalyst (18, 0)]
		[Export ("conditionUnsupported")]
		bool ConditionUnsupported { get; }

		[NoTV, Mac (15, 0), iOS (18, 0), MacCatalyst (18, 0)]
		[Export ("conditionLimitExceeded")]
		bool ConditionLimitExceeded { get; }

		[NoTV, Mac (15, 0), iOS (18, 0), MacCatalyst (18, 0)]
		[Export ("persistenceUnavailable")]
		bool PersistenceUnavailable { get; }

		[NoTV, Mac (15, 0), iOS (18, 0), MacCatalyst (18, 0)]
		[Export ("serviceSessionRequired")]
		bool ServiceSessionRequired { get; }

		[NoTV, Mac (15, 0), iOS (18, 0), MacCatalyst (18, 0)]
		[Export ("authorizationRequestInProgress")]
		bool AuthorizationRequestInProgress { get; }
	}

	[NoTV, Mac (14, 0), iOS (17, 0), MacCatalyst (17, 0)]
	[BaseType (typeof (NSObject))]
	interface CLMonitorConfiguration {
		[Export ("name")]
		string Name { get; }

		[Export ("queue")]
		DispatchQueue Queue { get; }

		[Export ("eventHandler")]
		Action<CLMonitor, CLMonitoringEvent> EventHandler { get; }

		[Static]
		[Export ("configWithMonitorName:queue:eventHandler:")]
		CLMonitorConfiguration Create (string name, DispatchQueue queue, Action<CLMonitor, CLMonitoringEvent> eventHandler);
	}

	[NoTV, Mac (14, 0), iOS (17, 0), MacCatalyst (17, 0)]
	[BaseType (typeof (NSObject))]
	[DisableDefaultCtor]
	interface CLMonitor {
		[Async]
		[Static]
		[Export ("requestMonitorWithConfiguration:completion:")]
		void RequestMonitor (CLMonitorConfiguration config, Action<CLMonitor> completionHandler);

		[Export ("name")]
		string Name { get; }

		[Export ("monitoredIdentifiers")]
		string [] MonitoredIdentifiers { get; }

		[Export ("addConditionForMonitoring:identifier:")]
		void AddCondition (CLCondition condition, string identifier);

		[Export ("addConditionForMonitoring:identifier:assumedState:")]
		void AddCondition (CLCondition condition, string identifier, CLMonitoringState state);

		[Export ("removeConditionFromMonitoringWithIdentifier:")]
		void RemoveCondition (string identifier);

		[Export ("monitoringRecordForIdentifier:")]
		[return: NullAllowed]
		CLMonitoringRecord GetMonitoringRecord (string identifier);
	}

	[TV (17, 0), Mac (14, 0), iOS (17, 0), MacCatalyst (17, 0)]
	[BaseType (typeof (NSObject))]
	[DisableDefaultCtor]
	interface CLLocationUpdater {
		[Static]
		[Export ("liveUpdaterWithQueue:handler:")]
		[return: NullAllowed]
		CLLocationUpdater CreateLiveUpdates (DispatchQueue queue, Action<CLUpdate> handler);

		[Static]
		[Export ("liveUpdaterWithConfiguration:queue:handler:")]
		[return: NullAllowed]
		CLLocationUpdater CreateLiveUpdates (CLLiveUpdateConfiguration configuration, DispatchQueue queue, Action<CLUpdate> handler);

		[Export ("resume")]
		void Resume ();

		[Export ("pause")]
		void Pause ();

		[Export ("invalidate")]
		void Invalidate ();
	}

	[NoTV, Mac (14, 0), iOS (17, 0), MacCatalyst (17, 0)]
	[BaseType (typeof (NSObject))]
	interface CLCondition : NSSecureCoding, NSCopying { }

	[NoTV, Mac (14, 0), iOS (17, 0), MacCatalyst (17, 0)]
	[BaseType (typeof (CLCondition))]
	interface CLCircularGeographicCondition : NSSecureCoding {
		[Export ("center")]
		CLLocationCoordinate2D Center { get; }

		[Export ("radius")]
		double Radius { get; }

		[Export ("initWithCenter:radius:")]
		NativeHandle Constructor (CLLocationCoordinate2D center, double radius);
	}

	[NoTV, Mac (14, 0), iOS (17, 0), MacCatalyst (17, 0)]
	[BaseType (typeof (CLCondition))]
	[DisableDefaultCtor]
	interface CLBeaconIdentityCondition : NSCopying, NSSecureCoding {
		[Export ("UUID", ArgumentSemantic.Copy)]
		NSUuid Uuid { get; }

		[NullAllowed]
		[Export ("major", ArgumentSemantic.Copy)]
		NSNumber Major { get; }

		[NullAllowed]
		[Export ("minor", ArgumentSemantic.Copy)]
		NSNumber Minor { get; }

		[Export ("initWithUUID:")]
		NativeHandle Constructor (NSUuid uuid);

		[Export ("initWithUUID:major:")]
		NativeHandle Constructor (NSUuid uuid, ushort major);

		[Export ("initWithUUID:major:minor:")]
		NativeHandle Constructor (NSUuid uuid, ushort major, ushort minor);
	}

	delegate void CLBackgroundActivitySessionCreateHandler (CLBackgroundActivitySessionDiagnostic diagnostic);

	[TV (18, 0), NoMac, iOS (17, 0), MacCatalyst (17, 0)]
	[BaseType (typeof (NSObject))]
	[DisableDefaultCtor]
	interface CLBackgroundActivitySession {
		[NoMac, iOS (17, 0)]
		[Export ("invalidate")]
		void Invalidate ();

		[NoMac, iOS (17, 0)]
		[Static]
		[Export ("backgroundActivitySession")]
		CLBackgroundActivitySession Create ();

		[TV (18, 0), NoMac, iOS (18, 0), MacCatalyst (18, 0)]
		[Static]
		[Export ("backgroundActivitySessionWithQueue:handler:")]
		CLBackgroundActivitySession Create (DispatchQueue queue, CLBackgroundActivitySessionCreateHandler handler);
	}

	[TV (18, 0), NoMac, iOS (18, 0), MacCatalyst (18, 0)]
	[BaseType (typeof (NSObject))]
	interface CLBackgroundActivitySessionDiagnostic {
		[Export ("authorizationDenied")]
		bool AuthorizationDenied { get; }

		[Export ("authorizationDeniedGlobally")]
		bool AuthorizationDeniedGlobally { get; }

		[Export ("authorizationRestricted")]
		bool AuthorizationRestricted { get; }

		[Export ("insufficientlyInUse")]
		bool InsufficientlyInUse { get; }

		[Export ("serviceSessionRequired")]
		bool ServiceSessionRequired { get; }

		[Export ("authorizationRequestInProgress")]
		bool AuthorizationRequestInProgress { get; }
	}

	[Native]
	[TV (18, 0), NoMac, iOS (18, 0), MacCatalyst (18, 0)]
	public enum CLServiceSessionAuthorizationRequirement : long {
		None = 0,
		WhenInUse = 1,
		[NoTV, NoMac]
		Always = 2,
	}

	[TV (18, 0), NoMac, iOS (18, 0), MacCatalyst (18, 0)]
	[BaseType (typeof (NSObject))]
	[DisableDefaultCtor]
	interface CLServiceSessionDiagnostic {
		[Export ("authorizationDenied")]
		bool AuthorizationDenied { get; }

		[Export ("authorizationDeniedGlobally")]
		bool AuthorizationDeniedGlobally { get; }

		[Export ("authorizationRestricted")]
		bool AuthorizationRestricted { get; }

		[Export ("insufficientlyInUse")]
		bool InsufficientlyInUse { get; }

		[Export ("serviceSessionRequired")]
		bool ServiceSessionRequired { get; }

		[Export ("fullAccuracyDenied")]
		bool FullAccuracyDenied { get; }

		[Export ("alwaysAuthorizationDenied")]
		bool AlwaysAuthorizationDenied { get; }

		[Export ("authorizationRequestInProgress")]
		bool AuthorizationRequestInProgress { get; }
	}

	delegate void CLServiceSessionCreateHandler (CLServiceSessionDiagnostic diagnostic);

	[TV (18, 0), NoMac, iOS (18, 0), MacCatalyst (18, 0)]
	[BaseType (typeof (NSObject))]
	[DisableDefaultCtor]
	interface CLServiceSession {
		[Static]
		[Export ("sessionRequiringAuthorization:")]
		CLServiceSession CreateSession (CLServiceSessionAuthorizationRequirement authorizationRequirement);

		[Static]
		[Export ("sessionRequiringAuthorization:queue:handler:")]
		CLServiceSession CreateSession (CLServiceSessionAuthorizationRequirement authorizationRequirement, DispatchQueue queue, CLServiceSessionCreateHandler handler);

		[Static]
		[Export ("sessionRequiringAuthorization:fullAccuracyPurposeKey:")]
		CLServiceSession CreateSession (CLServiceSessionAuthorizationRequirement authorizationRequirement, string fullAccuracyPurposeKey);

		[Static]
		[Export ("sessionRequiringAuthorization:fullAccuracyPurposeKey:queue:handler:")]
		CLServiceSession CreateSession (CLServiceSessionAuthorizationRequirement authorizationRequirement, string fullAccuracyPurposeKey, DispatchQueue queue, CLServiceSessionCreateHandler handler);

		[Export ("invalidate")]
		void Invalidate ();
	}
}
